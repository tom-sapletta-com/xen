<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>xeen â€” Screenshot â†’ Video</title>
<style>
:root {
  --bg: #0f0f13;
  --surface: #1a1a24;
  --surface2: #24243a;
  --border: #2d2d44;
  --text: #e4e4ef;
  --text2: #8888aa;
  --accent: #7c5cfc;
  --accent2: #5c9cfc;
  --green: #4cda8a;
  --red: #fc5c7c;
  --orange: #fcac5c;
  --radius: 10px;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Inter', -apple-system, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }

/* â”€â”€â”€ Header â”€â”€â”€â”€â”€â”€â”€ */
.header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 16px 24px; border-bottom: 1px solid var(--border);
}
.header h1 { font-size: 20px; font-weight: 700; }
.header h1 span { color: var(--accent); }
.header .session-info { color: var(--text2); font-size: 13px; }
.session-select { background: var(--surface2); color: var(--text); border: 1px solid var(--border); padding: 6px 12px; border-radius: 6px; font-size: 13px; }

/* â”€â”€â”€ Tabs â”€â”€â”€â”€â”€â”€â”€ */
.tabs {
  display: flex; gap: 0; border-bottom: 1px solid var(--border);
  padding: 0 24px; background: var(--surface);
}
.tab {
  padding: 12px 20px; cursor: pointer; color: var(--text2);
  font-size: 13px; font-weight: 500; border-bottom: 2px solid transparent;
  transition: all 0.2s; user-select: none;
}
.tab:hover { color: var(--text); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab .num {
  display: inline-block; width: 20px; height: 20px; line-height: 20px;
  text-align: center; border-radius: 50%; background: var(--surface2);
  font-size: 11px; margin-right: 6px;
}
.tab.active .num { background: var(--accent); color: white; }

/* â”€â”€â”€ Content â”€â”€â”€â”€â”€â”€â”€ */
.content { padding: 24px; max-width: 1400px; margin: 0 auto; }
.panel { display: none; }
.panel.active { display: block; }
.panel-header { margin-bottom: 20px; }
.panel-header h2 { font-size: 18px; margin-bottom: 4px; }
.panel-header p { color: var(--text2); font-size: 13px; }

/* â”€â”€â”€ Grid â”€â”€â”€â”€â”€â”€â”€ */
.frame-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 12px;
}
.frame-card {
  background: var(--surface); border: 2px solid var(--border);
  border-radius: var(--radius); overflow: hidden; cursor: pointer;
  transition: all 0.2s; position: relative;
}
.frame-card:hover { border-color: var(--accent); transform: translateY(-2px); }
.frame-card.selected { border-color: var(--green); }
.frame-card img { width: 100%; display: block; }
.frame-card .meta {
  padding: 8px 12px; font-size: 12px; color: var(--text2);
  display: flex; justify-content: space-between;
}
.frame-card .check {
  position: absolute; top: 8px; right: 8px;
  width: 24px; height: 24px; border-radius: 50%;
  background: var(--border); display: flex; align-items: center;
  justify-content: center; font-size: 14px;
}
.frame-card.selected .check { background: var(--green); color: white; }
.frame-card .del-frame {
  position: absolute; top: 8px; left: 8px;
  width: 24px; height: 24px; border-radius: 50%;
  background: rgba(252,92,124,0.0); border: none; color: transparent;
  display: flex; align-items: center; justify-content: center;
  font-size: 13px; cursor: pointer; transition: all 0.15s; line-height: 1;
}
.frame-card:hover .del-frame {
  background: rgba(252,92,124,0.85); color: white;
}
.frame-card .del-frame:hover { background: var(--red) !important; }
.frame-card.frame-missing { border-color: var(--red); opacity: 0.75; }
.frame-missing-overlay {
  background: rgba(252,92,124,0.12);
  min-height: 120px;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  font-size: 13px; color: var(--red); text-align: center; padding: 12px;
}
.frame-missing-overlay small { color: var(--text2); font-size: 10px; margin-top: 4px; word-break: break-all; }
.missing-frames-banner {
  display: none;
  align-items: flex-start;
  gap: 8px;
  background: rgba(252,172,92,0.12);
  border: 1px solid var(--orange);
  border-radius: var(--radius);
  padding: 12px 16px;
  margin-bottom: 16px;
  font-size: 13px;
  color: var(--orange);
  line-height: 1.5;
}

/* â”€â”€â”€ Trash Sidebar â”€â”€â”€â”€â”€â”€â”€ */
.trash-sidebar {
  position: fixed;
  right: 0; top: 0; bottom: 0;
  width: 260px;
  background: var(--surface);
  border-left: 1px solid var(--border);
  display: flex; flex-direction: column;
  transform: translateX(100%);
  transition: transform 0.3s;
  z-index: 200;
}
.trash-sidebar.open { transform: translateX(0); }
.trash-toggle {
  position: fixed;
  right: 16px; bottom: 80px;
  width: 48px; height: 48px;
  border-radius: 50%;
  background: var(--surface2);
  border: 1px solid var(--border);
  color: var(--text2);
  font-size: 22px;
  cursor: pointer;
  display: flex; align-items: center; justify-content: center;
  z-index: 201;
  transition: all 0.2s;
  box-shadow: 0 4px 12px rgba(0,0,0,.4);
}
.trash-toggle:hover { border-color: var(--red); color: var(--red); }
.trash-toggle .badge {
  position: absolute; top: -4px; right: -4px;
  background: var(--red); color: white;
  font-size: 10px; font-weight: 700;
  width: 18px; height: 18px; border-radius: 50%;
  display: none; align-items: center; justify-content: center;
}
.trash-toggle .badge.show { display: flex; }
.trash-header {
  padding: 16px;
  border-bottom: 1px solid var(--border);
  display: flex; align-items: center; justify-content: space-between;
}
.trash-header h3 { font-size: 14px; font-weight: 600; }
.trash-close {
  background: none; border: none; color: var(--text2);
  cursor: pointer; font-size: 18px; line-height: 1;
}
.trash-close:hover { color: var(--text); }
.trash-list {
  flex: 1; overflow-y: auto;
  padding: 8px;
  display: flex; flex-direction: column; gap: 6px;
}
.trash-item {
  background: var(--surface2);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px 10px;
  display: flex; align-items: center; gap: 8px;
}
.trash-item img {
  width: 40px; height: 40px; object-fit: cover;
  border-radius: 4px; flex-shrink: 0;
}
.trash-item-info {
  flex: 1; overflow: hidden;
}
.trash-item-name {
  font-size: 11px; color: var(--text2);
  overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
}
.trash-item-actions { display: flex; gap: 4px; }
.trash-item-restore {
  background: none; border: 1px solid var(--border);
  color: var(--text2); border-radius: 6px;
  padding: 2px 6px; font-size: 10px; cursor: pointer;
  white-space: nowrap;
}
.trash-item-restore:hover { border-color: var(--green); color: var(--green); }
.trash-item-purge {
  background: none; border: none;
  color: var(--text2); cursor: pointer; font-size: 13px;
}
.trash-item-purge:hover { color: var(--red); }
.trash-empty-msg {
  text-align: center; padding: 40px 16px;
  color: var(--text2); font-size: 13px;
}
.trash-footer {
  padding: 12px 16px;
  border-top: 1px solid var(--border);
}
.btn-danger { background: var(--red); color: white; width: 100%; }
.btn-danger:hover { background: #e04060; }
.tab-sessions {
  padding: 12px 20px; color: var(--text2);
  font-size: 13px; font-weight: 500;
  text-decoration: none; border-bottom: 2px solid transparent;
  transition: color 0.2s; user-select: none;
  margin-right: 8px; border-right: 1px solid var(--border);
}
.tab-sessions:hover { color: var(--text); }

/* â”€â”€â”€ Tools Toolbar â”€â”€â”€â”€â”€â”€â”€ */
.tools-bar {
  display: flex; flex-wrap: wrap; gap: 6px;
  padding: 10px 0; margin-bottom: 12px;
  border-bottom: 1px solid var(--border);
}
.tool-btn {
  display: inline-flex; align-items: center; gap: 5px;
  padding: 6px 12px; border-radius: 8px;
  background: var(--surface2); border: 1px solid var(--border);
  color: var(--text2); font-size: 12px; cursor: pointer;
  transition: all 0.15s; white-space: nowrap;
}
.tool-btn:hover { border-color: var(--accent); color: var(--text); }
.tool-btn.danger:hover { border-color: var(--red); color: var(--red); }
.tool-btn.success:hover { border-color: var(--green); color: var(--green); }
.tool-btn .icon { font-size: 14px; }
.tool-btn .badge-count {
  background: var(--red); color: white;
  font-size: 10px; font-weight: 700;
  padding: 1px 5px; border-radius: 10px;
  min-width: 16px; text-align: center;
}
.tool-btn.advanced { border-style: dashed; opacity: 0.6; }
.tool-btn.advanced:hover { opacity: 1; }
.tools-divider {
  width: 1px; background: var(--border);
  margin: 0 4px; align-self: stretch;
}

/* â”€â”€â”€ Export Controls â”€â”€â”€â”€â”€â”€â”€ */
.export-options {
  display: grid; gap: 16px; margin-bottom: 20px;
}
.export-row {
  display: grid; grid-template-columns: 120px 1fr; align-items: center; gap: 12px;
}
.export-row label {
  font-size: 13px; font-weight: 500; color: var(--text);
}
.export-row input[type="range"] {
  width: 100%; height: 6px; border-radius: 3px;
  background: var(--surface2); outline: none; -webkit-appearance: none;
}
.export-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
  border-radius: 50%; background: var(--accent); cursor: pointer;
  border: 2px solid var(--bg);
}
.export-row input[type="range"]::-moz-range-thumb {
  width: 18px; height: 18px; border-radius: 50%; background: var(--accent);
  cursor: pointer; border: 2px solid var(--bg);
}
.range-value {
  font-size: 14px; font-weight: 600; color: var(--accent);
  min-width: 40px; text-align: center;
}
.range-labels {
  display: flex; justify-content: space-between; font-size: 11px; color: var(--text2);
  margin-top: 4px;
}

.format-buttons {
  display: flex; gap: 12px; margin: 20px 0; flex-wrap: wrap;
}
.format-btn {
  display: flex; flex-direction: column; align-items: center; gap: 8px;
  padding: 16px 20px; border: 2px solid var(--border); border-radius: 12px;
  background: var(--surface1); color: var(--text); cursor: pointer;
  transition: all 0.2s; min-width: 80px;
}
.format-btn:hover {
  border-color: var(--accent); background: var(--surface2); transform: translateY(-2px);
}
.format-btn.active {
  border-color: var(--accent); background: var(--accent); color: var(--bg);
}
.format-icon {
  font-size: 24px;
}
.format-name {
  font-size: 12px; font-weight: 500;
}

.export-links {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 16px;
  margin-top: 12px;
}
.export-links a {
  display: inline-flex; align-items: center; gap: 8px;
  padding: 8px 12px; background: var(--surface1); border: 1px solid var(--border);
  border-radius: 6px; color: var(--text); text-decoration: none;
  font-size: 13px; transition: all 0.2s;
}
.export-links a:hover {
  border-color: var(--accent); background: var(--surface2);
}
.export-error {
  padding: 8px 12px; background: var(--red); color: white;
  border-radius: 6px; font-size: 13px; margin-bottom: 8px;
}

.export-preview {
  border: 1px solid var(--border); border-radius: 8px;
  background: var(--surface1); overflow: hidden;
  display: flex; flex-direction: column;
  height: 100%;
}
.preview-header {
  display: flex; justify-content: space-between; align-items: center;
  padding: 8px 12px; background: var(--surface2);
  border-bottom: 1px solid var(--border);
}
.format-badge {
  background: var(--accent); color: var(--bg);
  padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: 600;
}
.download-link {
  color: var(--text); text-decoration: none; font-size: 12px;
  transition: color 0.2s;
}
.download-link:hover {
  color: var(--accent);
}
.preview-content {
  padding: 12px; display: flex; justify-content: center;
  background: var(--bg); flex: 1;
  min-height: 200px;
}
.preview-media {
  width: 100%; height: 100%;
  max-height: 200px;
  object-fit: contain;
  border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}
.preview-icon {
  font-size: 48px; opacity: 0.5;
}

/* â”€â”€â”€ Focus Mode Controls â”€â”€â”€â”€â”€â”€â”€ */
.focus-option {
  display: flex; align-items: center; gap: 6px;
  padding: 8px 12px; border: 1px solid var(--border); border-radius: 6px;
  background: var(--surface2); cursor: pointer; transition: all 0.2s;
  font-size: 12px; color: var(--text2);
}
.focus-option:hover {
  border-color: var(--accent); color: var(--text);
}
.focus-option input[type="radio"] {
  accent-color: var(--accent);
}
.focus-option input[type="radio"]:checked + span {
  color: var(--accent); font-weight: 500;
}
.focus-option:has(input:checked) {
  border-color: var(--accent); background: rgba(124,92,252,.1);
}

#zoomSlider::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
  border-radius: 50%; background: var(--accent); cursor: pointer;
  border: 2px solid var(--bg);
}
#zoomSlider::-moz-range-thumb {
  width: 18px; height: 18px; border-radius: 50%; background: var(--accent);
  cursor: pointer; border: 2px solid var(--bg);
}
#paddingSlider::-webkit-slider-thumb {
  -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
  border-radius: 50%; background: var(--accent); cursor: pointer;
  border: 2px solid var(--bg);
}
#paddingSlider::-moz-range-thumb {
  width: 18px; height: 18px; border-radius: 50%; background: var(--accent);
  cursor: pointer; border: 2px solid var(--bg);
}
.mode-toggle {
  margin-left: auto;
  display: flex; align-items: center; gap: 6px;
  font-size: 11px; color: var(--text2);
}
.mode-toggle input { accent-color: var(--accent); }

/* â”€â”€â”€ Duplicate markers â”€â”€â”€â”€â”€â”€â”€ */
.frame-card.duplicate { border-color: var(--orange); }
.frame-card.duplicate::after {
  content: 'duplikat'; position: absolute;
  bottom: 32px; left: 50%; transform: translateX(-50%);
  background: var(--orange); color: #000;
  font-size: 10px; font-weight: 700;
  padding: 2px 8px; border-radius: 4px;
  pointer-events: none;
}
.dup-similarity {
  position: absolute; top: 36px; right: 8px;
  background: rgba(252,172,92,0.9); color: #000;
  font-size: 10px; font-weight: 600;
  padding: 1px 5px; border-radius: 4px;
}

/* â”€â”€â”€ Annotate â”€â”€â”€â”€â”€â”€â”€ */
.annotate-workspace {
  display: flex; gap: 16px;
}
.annotate-frame-list {
  width: 120px; flex-shrink: 0;
  display: flex; flex-direction: column; gap: 6px;
  max-height: 70vh; overflow-y: auto;
}
.annotate-thumb {
  border: 2px solid var(--border); border-radius: 6px;
  cursor: pointer; overflow: hidden; position: relative;
}
.annotate-thumb.active { border-color: var(--accent); }
.annotate-thumb img { width: 100%; display: block; }
.annotate-thumb .idx {
  position: absolute; top: 2px; left: 4px;
  font-size: 10px; color: white; text-shadow: 0 1px 3px rgba(0,0,0,.8);
}
.annotate-canvas-wrap {
  flex: 1; position: relative; background: var(--surface);
  border-radius: var(--radius); overflow: hidden;
  display: flex; align-items: flex-start; justify-content: center;
}
.annotate-canvas-wrap canvas {
  max-width: 100%; max-height: 70vh; cursor: crosshair; display: block;
}
.annotate-color-btn {
  width: 24px; height: 24px; border-radius: 50%;
  border: 2px solid var(--border); cursor: pointer;
}
.annotate-color-btn.active { border-color: white; box-shadow: 0 0 0 2px var(--accent); }
.annotate-size-range { width: 80px; vertical-align: middle; }

/* â”€â”€â”€ Center Grid (new) â”€â”€â”€â”€â”€â”€â”€ */
.center-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 12px;
}
.center-grid-card {
  border: 2px solid var(--border); border-radius: 8px;
  overflow: hidden; background: var(--surface);
  transition: border-color 0.15s;
}
.center-grid-card.active  { border-color: var(--accent); }
.center-grid-card.marked  { border-color: var(--green); }
.center-grid-card:hover   { border-color: var(--accent); }
.center-grid-card .cgc-img-wrap {
  position: relative; cursor: crosshair; overflow: hidden;
}
.center-grid-card .cgc-img-wrap img {
  width: 100%; display: block; pointer-events: none;
}
.center-grid-card .cgc-dot {
  position: absolute; width: 14px; height: 14px; border-radius: 50%;
  transform: translate(-50%, -50%); pointer-events: none;
  border: 2px solid white; box-shadow: 0 0 6px rgba(0,0,0,.6);
}
.center-grid-card .cgc-dot.user   { background: var(--green); }
.center-grid-card .cgc-dot.mouse  { background: var(--red); }
.center-grid-card .cgc-label {
  padding: 5px 8px; font-size: 11px; color: var(--text2);
  display: flex; justify-content: space-between; align-items: center;
}
.center-grid-card .cgc-label b { color: var(--text); }

/* â”€â”€â”€ Mouse Position Matrix (kept for compat) â”€â”€â”€â”€â”€â”€â”€ */
.mouse-matrix-container {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 16px;
}
.mouse-matrix {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  max-height: 400px;
  overflow-y: auto;
}
.mouse-matrix-item {
  position: relative;
  background: var(--surface2);
  border: 2px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  transition: all 0.2s;
  aspect-ratio: 16/9;
}
.mouse-matrix-item:hover {
  border-color: var(--accent);
  transform: scale(1.02);
}
.mouse-matrix-item.active {
  border-color: var(--green);
  box-shadow: 0 0 0 2px rgba(76,218,138,0.3);
}
.mouse-matrix-item.marked {
  border-color: var(--orange);
}
.mouse-matrix-item img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}
.mouse-matrix-item .frame-number {
  position: absolute;
  top: 4px;
  left: 4px;
  background: rgba(0,0,0,.8);
  color: white;
  font-size: 10px;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
}
.mouse-matrix-item .mouse-position {
  position: absolute;
  bottom: 4px;
  right: 4px;
  background: rgba(252,92,124,.9);
  color: white;
  font-size: 9px;
  font-weight: 600;
  padding: 2px 4px;
  border-radius: 3px;
  pointer-events: none;
}
.mouse-matrix-item .center-mark {
  position: absolute;
  width: 12px;
  height: 12px;
  border: 2px solid var(--green);
  border-radius: 50%;
  background: rgba(76,218,138,.3);
  transform: translate(-50%, -50%);
  pointer-events: none;
}
.mouse-matrix-item .suggested-center {
  position: absolute;
  width: 8px;
  height: 8px;
  background: var(--red);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}

/* â”€â”€â”€ Crop Preview â”€â”€â”€â”€â”€â”€â”€ */
.preset-bar {
  display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 16px;
}
.preset-btn {
  padding: 8px 14px; border: 1px solid var(--border); background: var(--surface);
  color: var(--text); border-radius: 6px; cursor: pointer; font-size: 12px;
  transition: all 0.2s;
}
.preset-btn:hover { border-color: var(--accent); }
.preset-btn.active { background: var(--accent); border-color: var(--accent); color: white; }

.crop-preview-grid {
  display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr));
  gap: 12px;
}
.crop-card {
  background: var(--surface); border-radius: var(--radius);
  overflow: hidden; border: 1px solid var(--border);
}
.crop-card img { width: 100%; display: block; }
.crop-card .info { padding: 8px; font-size: 11px; color: var(--text2); }

/* â”€â”€â”€ Captions / Napisy â”€â”€â”€â”€â”€â”€â”€ */
.captions-layout {
  display: grid;
  grid-template-columns: 1fr 380px;
  gap: 20px;
  height: calc(100vh - 280px);
  min-height: 500px;
}
.captions-timeline {
  display: flex; flex-direction: column; gap: 0; overflow-y: auto;
  background: var(--surface); border-radius: var(--radius);
  border: 1px solid var(--border);
}
.caption-row {
  display: grid;
  grid-template-columns: 56px 1fr 80px;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  transition: background 0.15s;
  position: relative;
}
.caption-row:hover { background: var(--surface2); }
.caption-row.active { background: rgba(124,92,252,.15); border-left: 3px solid var(--accent); }
.caption-row .cap-thumb {
  width: 50px; height: 32px; object-fit: cover;
  border-radius: 4px; background: var(--bg);
  border: 1px solid var(--border);
}
.caption-row .cap-text {
  font-size: 12px; color: var(--text);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.caption-row .cap-frames {
  font-size: 10px; color: var(--text2); text-align: right;
}
.caption-row .cap-del {
  position: absolute; right: 6px; top: 6px;
  background: none; border: none; color: var(--text2); cursor: pointer; font-size: 13px;
  display: none;
}
.caption-row:hover .cap-del { display: block; }
.caption-row .cap-del:hover { color: var(--red); }

.caption-editor {
  display: flex; flex-direction: column; gap: 12px;
  background: var(--surface); border-radius: var(--radius);
  border: 1px solid var(--border); padding: 16px; overflow-y: auto;
}
.cap-preview-wrap {
  position: relative; background: #000; border-radius: 6px;
  overflow: hidden; flex-shrink: 0;
}
.cap-preview-wrap img { width: 100%; display: block; }
.cap-overlay-text {
  position: absolute; left: 50%; transform: translateX(-50%);
  padding: 4px 12px; border-radius: 4px;
  pointer-events: none; white-space: pre-wrap; text-align: center;
  max-width: 90%;
}
.cap-field { display: flex; flex-direction: column; gap: 4px; }
.cap-field label { font-size: 11px; color: var(--text2); font-weight: 500; }
.cap-field input[type="text"],
.cap-field textarea,
.cap-field select,
.cap-field input[type="number"] {
  background: var(--surface2); color: var(--text);
  border: 1px solid var(--border); border-radius: 6px;
  padding: 6px 8px; font-size: 13px; width: 100%;
}
.cap-field textarea { resize: vertical; min-height: 64px; font-family: inherit; }
.cap-row-inline { display: flex; gap: 8px; }
.cap-row-inline .cap-field { flex: 1; }

.llm-panel {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 16px; margin-bottom: 16px;
}
.llm-panel h4 { font-size: 13px; margin: 0 0 12px 0; color: var(--text); }
.llm-fields { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px; }
.llm-fields label { font-size: 11px; color: var(--text2); display: block; margin-bottom: 4px; }
.llm-fields select, .llm-fields input {
  width: 100%; background: var(--surface2); color: var(--text);
  border: 1px solid var(--border); border-radius: 6px;
  padding: 6px 8px; font-size: 12px;
}
.llm-api-row {
  display: flex; gap: 8px; align-items: center; margin-bottom: 10px;
}
.llm-api-row input {
  flex: 1; background: var(--surface2); color: var(--text);
  border: 1px solid var(--border); border-radius: 6px;
  padding: 6px 8px; font-size: 12px; font-family: monospace;
}

/* â”€â”€â”€ Transitions Panel â”€â”€â”€â”€â”€â”€â”€ */
.transitions-global {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 14px; margin-bottom: 16px;
  display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
}
.transitions-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px; margin-bottom: 16px; }
.transition-card {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: var(--radius); padding: 10px; display: flex; flex-direction: column; gap: 6px;
}
.transition-card img { width: 100%; aspect-ratio: 16/9; object-fit: cover; border-radius: 6px; background: var(--surface2); }
.transition-card .tc-label { font-size: 11px; font-weight: 600; color: var(--text); }
.transition-card .tc-arrow { font-size: 10px; color: var(--text2); text-align: center; }
.transition-card select { width: 100%; background: var(--surface2); color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 4px 6px; font-size: 12px; }
.cap-copy-row { display: flex; gap: 6px; align-items: center; margin-top: 4px; }
.cap-copy-row input[type="number"] { width: 56px; padding: 4px 6px; background: var(--surface2); color: var(--text); border: 1px solid var(--border); border-radius: 6px; font-size: 12px; }

/* â”€â”€â”€ Watermark Configurator â”€â”€â”€â”€â”€â”€â”€ */
.wm-config {
  background: var(--surface); border: 1px solid var(--border);
  border-radius: 10px; padding: 14px; margin-bottom: 16px;
}
.wm-config h4 { font-size: 13px; margin: 0 0 12px 0; color: var(--text); }
.wm-row { display: flex; gap: 10px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; }
.wm-row label { font-size: 11px; color: var(--text2); min-width: 80px; }
.wm-row input[type="text"],
.wm-row input[type="number"],
.wm-row select {
  flex: 1; background: var(--surface2); color: var(--text);
  border: 1px solid var(--border); border-radius: 6px;
  padding: 5px 8px; font-size: 12px; min-width: 0;
}
.wm-row input[type="color"] {
  width: 36px; height: 28px; border: 1px solid var(--border);
  border-radius: 6px; cursor: pointer; padding: 2px; background: var(--surface2);
}
.wm-preview-wrap {
  position: relative; display: inline-block;
  background: #000; border-radius: 6px; overflow: hidden;
  cursor: crosshair; user-select: none;
}
.wm-preview-wrap img { max-width: 100%; max-height: 240px; display: block; object-fit: contain; }
.wm-pin {
  position: absolute; pointer-events: none;
  transform: translate(-50%, -50%);
  display: flex; flex-direction: column; align-items: center; gap: 2px;
}
.wm-pin-dot {
  width: 12px; height: 12px; border-radius: 50%;
  background: var(--accent); border: 2px solid white;
  box-shadow: 0 0 6px rgba(0,0,0,.6);
}
.wm-pin-label {
  background: rgba(0,0,0,.75); color: white;
  font-size: 9px; padding: 1px 4px; border-radius: 3px; white-space: nowrap;
}
.wm-hint { font-size: 11px; color: var(--text2); margin-bottom: 8px; }
.wm-logo-preview {
  max-height: 40px; border-radius: 4px; border: 1px solid var(--border);
  background: repeating-conic-gradient(#444 0% 25%, #222 0% 50%) 0 0 / 10px 10px;
}
.wm-transparent-btn {
  font-size: 11px; padding: 3px 8px; border-radius: 4px;
  background: var(--surface2); border: 1px solid var(--border);
  color: var(--text2); cursor: pointer;
}
.wm-transparent-btn.active { border-color: var(--accent); color: var(--accent); }

/* â”€â”€â”€ Publish â”€â”€â”€â”€â”€â”€â”€ */
.publish-section { max-width: 640px; }
.export-options { display: flex; flex-direction: column; gap: 12px; margin-bottom: 20px; }
.export-row { display: flex; gap: 12px; align-items: center; }
.export-row label { width: 120px; font-size: 13px; color: var(--text2); }
.export-row select, .export-row input {
  flex: 1; padding: 8px; background: var(--surface2); color: var(--text);
  border: 1px solid var(--border); border-radius: 6px; font-size: 13px;
}
.social-links { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 16px; }
.social-btn {
  padding: 10px 18px; border-radius: 8px; font-size: 13px; font-weight: 500;
  cursor: pointer; border: none; color: white; transition: opacity 0.2s;
}
.social-btn:hover { opacity: 0.85; }
.social-btn.twitter { background: #1da1f2; }
.social-btn.linkedin { background: #0077b5; }
.social-btn.facebook { background: #4267b2; }
.social-btn.reddit { background: #ff4500; }
.social-btn.telegram { background: #0088cc; }

/* â”€â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€ */
.btn {
  padding: 10px 20px; border: none; border-radius: 8px;
  font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s;
}
.btn-primary { background: var(--accent); color: white; }
.btn-primary:hover { background: #6b4ce8; }
.btn-success { background: var(--green); color: #111; }
.btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text); }
.btn-outline:hover { border-color: var(--accent); }
.btn-group { display: flex; gap: 8px; margin-top: 16px; }

/* â”€â”€â”€ Upload zone â”€â”€â”€â”€â”€â”€â”€ */
.upload-zone {
  border: 2px dashed var(--border); border-radius: var(--radius);
  padding: 48px; text-align: center; color: var(--text2);
  cursor: pointer; transition: all 0.2s; margin-bottom: 20px;
}
.upload-zone:hover, .upload-zone.dragover {
  border-color: var(--accent); background: rgba(124,92,252,.05);
}
.upload-zone h3 { margin-bottom: 8px; color: var(--text); }

/* â”€â”€â”€ Empty state â”€â”€â”€â”€â”€â”€â”€ */
.empty-state { text-align: center; padding: 60px; color: var(--text2); }
.empty-state h3 { color: var(--text); margin-bottom: 8px; }

/* â”€â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€ */
.toast {
  position: fixed; bottom: 24px; right: 24px;
  background: var(--surface2); border: 1px solid var(--green);
  padding: 12px 20px; border-radius: 8px; font-size: 13px;
  transform: translateY(80px); opacity: 0; transition: all 0.3s;
  z-index: 1000;
}
.toast.show { transform: translateY(0); opacity: 1; }

/* â”€â”€â”€ Spinner â”€â”€â”€â”€â”€â”€â”€ */
.spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.6s linear infinite; }
@keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>

<div class="header">
  <h1><span>xeen</span> capture</h1>
  <div style="display:flex;align-items:center;gap:12px;">
    <span class="session-info" id="sessionInfo">Brak sesji</span>
    <select class="session-select" id="sessionSelect" onchange="loadSession(this.value)">
      <option value="">â€” wybierz sesjÄ™ â€”</option>
    </select>
  </div>
</div>

<div class="tabs" id="tabs">
  <a class="tab tab-sessions" href="/" title="PowrÃ³t do listy sesji">â† Sesje</a>
  <div class="tab active" data-tab="select">
    <span class="num">1</span>WybÃ³r klatek
  </div>
  <div class="tab" data-tab="annotate">
    <span class="num">2</span>Adnotacje
  </div>
  <div class="tab" data-tab="center">
    <span class="num">3</span>Åšrodek
  </div>
  <div class="tab" data-tab="crop">
    <span class="num">4</span>Przycinanie
  </div>
  <div class="tab" data-tab="captions">
    <span class="num">5</span>Napisy
  </div>
  <div class="tab" data-tab="transitions">
    <span class="num">6</span>PrzejÅ›cia
  </div>
  <div class="tab" data-tab="publish">
    <span class="num">7</span>Publikacja
  </div>
</div>

<!-- Trash toggle -->
<button class="trash-toggle" onclick="toggleTrash()" title="Kosz">
  ğŸ—‘
  <span class="badge" id="trashBadge"></span>
</button>

<!-- Trash sidebar -->
<div class="trash-sidebar" id="trashSidebar">
  <div class="trash-header">
    <h3>ğŸ—‘ Kosz klatek</h3>
    <button class="trash-close" onclick="toggleTrash()">âœ•</button>
  </div>
  <div class="trash-list" id="trashList">
    <div class="trash-empty-msg">Kosz jest pusty</div>
  </div>
  <div class="trash-footer">
    <button class="btn btn-danger" onclick="emptyFrameTrash()">OprÃ³Å¼nij kosz</button>
  </div>
</div>

<div class="content">

  <!-- â•â•â• Tab 1: Frame Selection â•â•â• -->
  <div class="panel active" id="panel-select">
    <div class="panel-header">
      <h2>WybÃ³r klatek</h2>
      <p>Kliknij aby zaznaczyÄ‡/odznaczyÄ‡ klatki. Zaznaczone przejdÄ… do dalszej edycji.</p>
    </div>

    <div class="tools-bar" id="toolsSelect">
      <button class="tool-btn danger" onclick="detectDuplicates()" title="ZnajdÅº klatki podobne >90%">
        <span class="icon">ğŸ”</span> ZnajdÅº duplikaty <span class="badge-count" id="dupCount" style="display:none"></span>
      </button>
      <button class="tool-btn danger" id="btnRemoveDups" onclick="removeDuplicates()" style="display:none" title="UsuÅ„ oznaczone duplikaty">
        <span class="icon">ğŸ—‘</span> UsuÅ„ duplikaty
      </button>
      <button class="tool-btn" onclick="sortByChange()" title="Sortuj wg % zmiany">
        <span class="icon">ğŸ“Š</span> Sortuj wg zmiany
      </button>
      <button class="tool-btn" onclick="invertSelection()" title="OdwrÃ³Ä‡ zaznaczenie">
        <span class="icon">ğŸ”„</span> OdwrÃ³Ä‡
      </button>
      <button class="tool-btn" onclick="selectEveryNth()" title="Zaznacz co N-tÄ… klatkÄ™">
        <span class="icon">#ï¸âƒ£</span> Co N-ta
      </button>
      <button class="tool-btn success" onclick="selectMostDifferent()" title="Zaznacz klatki z najwiÄ™kszymi zmianami">
        <span class="icon">âš¡</span> NajwiÄ™ksze zmiany
      </button>
      <button class="tool-btn" onclick="selectFirstN()" title="Zaznacz pierwsze N klatek">
        <span class="icon">ğŸ”¢</span> Pierwsze N
      </button>
      <button class="tool-btn" onclick="selectTimeRange()" title="Zaznacz klatki z zakresu czasu">
        <span class="icon">â±ï¸</span> Zakres czasu
      </button>
      <div class="tools-divider"></div>
      <button class="tool-btn advanced" onclick="advancedSimilarity()" title="Zaawansowana analiza (wymaga dodatkowych pakietÃ³w)">
        <span class="icon">ğŸ§ </span> AI detekcja
      </button>
      <div class="mode-toggle">
        <input type="checkbox" id="advancedMode" onchange="toggleAdvancedMode(this.checked)">
        <label for="advancedMode">Zaawansowane</label>
      </div>
    </div>

    <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
      <h3>ğŸ“¸ PrzeciÄ…gnij screenshoty lub kliknij aby wybraÄ‡</h3>
      <p>Lub uruchom <code>xeen capture</code> w terminalu (wymaga GUI)</p>
      <input type="file" id="fileInput" multiple accept="image/*" style="display:none" onchange="uploadFiles(this.files)">
    </div>

    <div class="missing-frames-banner" id="missingFramesBanner"></div>
    <div id="frameGrid" class="frame-grid"></div>

    <div class="btn-group">
      <button class="btn btn-outline" onclick="selectAllFrames()">Zaznacz wszystkie</button>
      <button class="btn btn-outline" onclick="deselectAllFrames()">Odznacz wszystkie</button>
      <button class="btn btn-primary" onclick="saveSelection(); navigateToTab('annotate')">Dalej â†’ Adnotacje</button>
    </div>
  </div>

  <!-- â•â•â• Tab 2: Annotate â•â•â• -->
  <div class="panel" id="panel-annotate">
    <div class="panel-header">
      <h2>Adnotacje</h2>
      <p>Dodaj strzaÅ‚ki, prostokÄ…ty i tekst na klatkach. PomiÅ„ jeÅ›li nie potrzebujesz.</p>
    </div>

    <div class="tools-bar">
      <button class="tool-btn success" id="annToolArrow" onclick="setAnnotateTool('arrow')" title="StrzaÅ‚ka">
        <span class="icon">â†—ï¸</span> StrzaÅ‚ka
      </button>
      <button class="tool-btn" id="annToolRect" onclick="setAnnotateTool('rect')" title="ProstokÄ…t / highlight">
        <span class="icon">â¬œ</span> ProstokÄ…t
      </button>
      <button class="tool-btn" id="annToolText" onclick="setAnnotateTool('text')" title="Tekst">
        <span class="icon">ğŸ…°</span> Tekst
      </button>
      <div class="tools-divider"></div>
      <button class="annotate-color-btn active" style="background:#fc5c7c" onclick="setAnnotateColor('#fc5c7c',this)" title="Czerwony"></button>
      <button class="annotate-color-btn" style="background:#fcac5c" onclick="setAnnotateColor('#fcac5c',this)" title="PomaraÅ„czowy"></button>
      <button class="annotate-color-btn" style="background:#5cfc7c" onclick="setAnnotateColor('#5cfc7c',this)" title="Zielony"></button>
      <button class="annotate-color-btn" style="background:#5cacfc" onclick="setAnnotateColor('#5cacfc',this)" title="Niebieski"></button>
      <button class="annotate-color-btn" style="background:#ffffff" onclick="setAnnotateColor('#ffffff',this)" title="BiaÅ‚y"></button>
      <div class="tools-divider"></div>
      <label style="font-size:11px;color:var(--text2)">GruboÅ›Ä‡:</label>
      <input type="range" class="annotate-size-range" min="2" max="10" value="3" id="annLineWidth">
      <div class="tools-divider"></div>
      <button class="tool-btn" onclick="undoAnnotation()" title="Cofnij">
        <span class="icon">â†©ï¸</span> Cofnij
      </button>
      <button class="tool-btn danger" onclick="clearAnnotations()" title="WyczyÅ›Ä‡">
        <span class="icon">ğŸ—‘</span> WyczyÅ›Ä‡
      </button>
    </div>

    <div class="annotate-workspace">
      <div class="annotate-frame-list" id="annotateFrameList"></div>
      <div class="annotate-canvas-wrap" id="annotateCanvasWrap">
        <canvas id="annotateCanvas" width="800" height="600"></canvas>
      </div>
    </div>

    <div class="btn-group">
      <button class="btn btn-outline" onclick="navigateToTab('select')">â† Wstecz</button>
      <button class="btn btn-outline" onclick="navigateToTab('center')">PomiÅ„ adnotacje â†’</button>
      <button class="btn btn-primary" onclick="saveAnnotations(); navigateToTab('center')">Dalej â†’ Åšrodek</button>
    </div>
  </div>

  <!-- â•â•â• Tab 3: Center Marking â•â•â• -->
  <div class="panel" id="panel-center">
    <div class="panel-header">
      <h2>Oznacz Å›rodek</h2>
      <p>Kliknij na obrazie aby wyznaczyÄ‡ punkt centralny. ğŸ”´ = kursor myszy z nagrania (sugestia).</p>
      <p style="font-size:11px;color:var(--text2);margin-top:4px">
        âŒ¨ï¸ <b>â†/â†’</b> kolejna klatka &nbsp;|&nbsp; <b>Spacja</b> zatwierdÅº sugestiÄ™ + dalej &nbsp;|&nbsp; <b>C</b> kopiuj z poprzedniej &nbsp;|&nbsp; <b>Enter</b> dalej â†’ Crop
      </p>
    </div>

    <div class="tools-bar">
      <button class="tool-btn success" onclick="autoCenters()" title="UÅ¼yj pozycji kursora z nagrania">
        <span class="icon">ğŸ¯</span> Auto: kursor myszy
      </button>
      <button class="tool-btn" onclick="centerToMiddle()" title="Ustaw Å›rodek na Å›rodek obrazu">
        <span class="icon">â•</span> Åšrodek obrazu
      </button>
      <button class="tool-btn" onclick="copyCenterToAll()" title="Kopiuj bieÅ¼Ä…cy Å›rodek do wszystkich klatek">
        <span class="icon">ğŸ“‹</span> Kopiuj do wszystkich
      </button>
      <button class="tool-btn" onclick="interpolateCenters()" title="Interpoluj brakujÄ…ce Å›rodki miÄ™dzy zaznaczonymi">
        <span class="icon">ğŸ“ˆ</span> Interpoluj
      </button>
      <button class="tool-btn danger" onclick="clearAllCenters()" title="UsuÅ„ wszystkie Å›rodki">
        <span class="icon">ğŸ—‘</span> WyczyÅ›Ä‡ Å›rodki
      </button>
      <div class="tools-divider"></div>
      <button class="tool-btn advanced" onclick="advancedAutoCenter()" title="AI detekcja punktu zainteresowania">
        <span class="icon">ğŸ§ </span> AI auto-center
      </button>
    </div>

    <!-- Focus grid: all selected frames, click to set focus point -->
    <div class="center-grid-header" style="display:flex;align-items:center;gap:12px;margin-bottom:10px;font-size:12px;color:var(--text2)">
      <span>ğŸŸ¢ = ustawiony fokus &nbsp; ğŸ”´ = sugestia myszy &nbsp; Kliknij na obrazie aby ustawiÄ‡ punkt fokus</span>
      <span id="centerGridStatus" style="margin-left:auto;color:var(--accent)"></span>
    </div>
    <div id="centerGrid" class="center-grid"></div>
    <div class="btn-group">
      <button class="btn btn-outline" onclick="navigateToTab('select')">â† Wstecz</button>
      <button class="btn btn-outline" onclick="autoCenters()">Auto (kursor myszy)</button>
      <button class="btn btn-primary" onclick="saveCenters(); navigateToTab('crop')">Dalej â†’ Przycinanie</button>
    </div>
  </div>

  <!-- â•â•â• Tab 3: Crop Preview â•â•â• -->
  <div class="panel" id="panel-crop">
    <div class="panel-header">
      <h2>Przycinanie</h2>
      <p>Wybierz format docelowy â€” podglÄ…d przyciÄ™tych klatek wg oznaczonego Å›rodka.</p>
    </div>

    <div class="tools-bar">
      <button class="tool-btn" onclick="previewAllPresets()" title="PodglÄ…d wszystkich formatÃ³w">
        <span class="icon">ğŸ–¼</span> PodglÄ…d wszystkich
      </button>
      <button class="tool-btn" onclick="fitToContent()" title="Dopasuj kadrowanie do treÅ›ci">
        <span class="icon">âœ‚ï¸</span> Dopasuj do treÅ›ci
      </button>
      <button class="tool-btn" onclick="addCustomPreset()" title="Dodaj wÅ‚asny format">
        <span class="icon">â•</span> WÅ‚asny format
      </button>
      <button class="tool-btn" onclick="resetCropDefaults()" title="PrzywrÃ³Ä‡ domyÅ›lne ustawienia">
        <span class="icon">â†©ï¸</span> Resetuj
      </button>
      <div class="tools-divider"></div>
      <button class="tool-btn advanced" onclick="advancedSmartCrop()" title="AI smart crop (wymaga opencv)">
        <span class="icon">ğŸ§ </span> AI smart crop
      </button>
      <button class="tool-btn advanced" onclick="advancedUpscale()" title="AI upscale (wymaga realesrgan)">
        <span class="icon">ğŸ§ </span> AI upscale
      </button>
    </div>

    <!-- Focus Mode Controls -->
    <div class="focus-controls" style="margin-bottom:20px;padding:16px;background:var(--surface);border-radius:8px;border:1px solid var(--border)">
      <h4 style="margin:0 0 12px 0;font-size:14px;color:var(--text)">ğŸ¯ Tryb focusu</h4>
      <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:8px;margin-bottom:16px">
        <label class="focus-option">
          <input type="radio" name="focusMode" value="screen" checked onchange="updateFocusMode('screen')">
          <span>ğŸ–¥ï¸ Ekran</span>
        </label>
        <label class="focus-option">
          <input type="radio" name="focusMode" value="mouse" onchange="updateFocusMode('mouse')">
          <span>ğŸ–±ï¸ Mysz</span>
        </label>
        <label class="focus-option">
          <input type="radio" name="focusMode" value="keyboard" onchange="updateFocusMode('keyboard')">
          <span>âŒ¨ï¸ Klawiatura</span>
        </label>
        <label class="focus-option">
          <input type="radio" name="focusMode" value="application" onchange="updateFocusMode('application')">
          <span>ğŸª¬ Aplikacja</span>
        </label>
      </div>
      
      <!-- Zoom Control -->
      <div id="zoomControls" style="display:none">
        <label style="font-size:13px;color:var(--text2);display:block;margin-bottom:8px">
          ğŸ” Zoom myszy: <span id="zoomValue">2.0x</span>
        </label>
        <input type="range" id="zoomSlider" min="1" max="10" value="2" step="0.5" 
               oninput="updateZoom(this.value)"
               style="width:100%;height:6px;border-radius:3px;background:var(--surface2);outline:none;-webkit-appearance:none">
        <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--text2);margin-top:4px">
          <span>1x</span><span>5x</span><span>10x</span>
        </div>
        
        <label style="font-size:13px;color:var(--text2);display:block;margin:12px 0 8px 0">
          ğŸ“ Obszar wokÃ³Å‚ myszy: <span id="paddingValue">20%</span>
        </label>
        <input type="range" id="paddingSlider" min="10" max="50" value="20" step="1" 
               oninput="updatePadding(this.value)"
               style="width:100%;height:6px;border-radius:3px;background:var(--surface2);outline:none;-webkit-appearance:none">
        <div style="display:flex;justify-content:space-between;font-size:11px;color:var(--text2);margin-top:4px">
          <span>10%</span><span>30%</span><span>50%</span>
        </div>
      </div>
      
      <!-- Video Preview -->
      <div id="videoPreviewContainer" style="margin-top:16px">
        <h5 style="margin:0 0 8px 0;font-size:13px;color:var(--text)">ğŸ¬ PodglÄ…d pierwszej klatki wideo</h5>
        <div id="videoPreview" style="background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:8px;min-height:120px;display:flex;align-items:center;justify-content:center;position:relative">
          <div style="color:var(--text2);font-size:12px;text-align:center">
            <div>â³ Generowanie podglÄ…du...</div>
            <small style="display:block;margin-top:4px">ZmieÅ„ ustawienia aby zobaczyÄ‡ efekt</small>
          </div>
        </div>
      </div>
    </div>

    <div class="preset-bar" id="presetBar"></div>
    <div id="cropPreviewGrid" class="crop-preview-grid"></div>
    <div class="btn-group">
      <button class="btn btn-outline" onclick="navigateToTab('center')">â† Wstecz</button>
      <button class="btn btn-primary" onclick="navigateToTab('captions')">Dalej â†’ Napisy</button>
    </div>
  </div>

  <!-- â•â•â• Tab 5: Captions / Napisy â•â•â• -->
  <div class="panel" id="panel-captions">
    <div class="panel-header">
      <h2>Napisy</h2>
      <p>Dodaj opisy do klatek â€” rÄ™cznie lub automatycznie przez AI. Pozycjonuj tekst jak w Canva.</p>
    </div>

    <div class="tools-bar">
      <button class="tool-btn success" onclick="addCaption()" title="Dodaj nowy napis">
        <span class="icon">â•</span> Dodaj napis
      </button>
      <button class="tool-btn" onclick="autoCaptionsFromFrames()" title="Auto: utwÃ³rz napis dla kaÅ¼dej klatki">
        <span class="icon">ğŸ”„</span> Auto (1 napis/klatka)
      </button>
      <button class="tool-btn" onclick="saveCaptions()" title="Zapisz napisy">
        <span class="icon">ğŸ’¾</span> Zapisz
      </button>
      <button class="tool-btn danger" onclick="clearAllCaptions()" title="UsuÅ„ wszystkie napisy">
        <span class="icon">ğŸ—‘</span> WyczyÅ›Ä‡
      </button>
    </div>

    <!-- LLM Panel -->
    <div class="llm-panel">
      <h4>ğŸ¤– Generowanie przez AI (LLM)</h4>
      <div class="llm-api-row">
        <span style="font-size:11px;color:var(--text2);white-space:nowrap">Klucz API:</span>
        <input type="password" id="llmApiKey" placeholder="sk-... (lub ustaw zmiennÄ… OPENAI_API_KEY)" 
               title="Zostaw puste jeÅ›li masz OPENAI_API_KEY w Å›rodowisku">
      </div>
      <div class="llm-fields">
        <div>
          <label>Provider</label>
          <select id="llmProvider" onchange="updateLlmModelPlaceholder()">
            <option value="openai">OpenAI</option>
            <option value="anthropic">Anthropic</option>
            <option value="ollama">Ollama (lokalny)</option>
            <option value="gemini">Google Gemini</option>
          </select>
        </div>
        <div>
          <label>Model</label>
          <input type="text" id="llmModel" value="gpt-4o-mini" placeholder="gpt-4o-mini">
        </div>
        <div>
          <label>JÄ™zyk</label>
          <select id="llmLanguage">
            <option value="pl">Polski</option>
            <option value="en">English</option>
            <option value="de">Deutsch</option>
          </select>
        </div>
        <div>
          <label>Styl napisÃ³w</label>
          <select id="llmStyle">
            <option value="tutorial">Tutorial (krok po kroku)</option>
            <option value="social">Social media</option>
            <option value="minimal">Minimalny</option>
            <option value="descriptive">Opisowy</option>
          </select>
        </div>
      </div>
      <button class="btn btn-primary" onclick="generateCaptionsLLM()" id="llmGenerateBtn">
        ğŸ¤– Generuj napisy AI
      </button>
      <span id="llmStatus" style="font-size:12px;color:var(--text2);margin-left:12px"></span>
    </div>

    <!-- Main editor layout -->
    <div class="captions-layout">
      <!-- Left: timeline/list -->
      <div>
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <span style="font-size:13px;font-weight:600;color:var(--text)">
            Lista napisÃ³w <span id="captionCount" style="color:var(--text2);font-weight:400">(0)</span>
          </span>
          <button class="tool-btn" style="padding:4px 10px;font-size:11px" onclick="addCaption()">+ Nowy</button>
        </div>
        <div class="captions-timeline" id="captionsList">
          <div style="text-align:center;padding:40px;color:var(--text2);font-size:13px">
            Brak napisÃ³w â€” dodaj rÄ™cznie lub wygeneruj AI
          </div>
        </div>
      </div>

      <!-- Right: editor -->
      <div class="caption-editor" id="captionEditor">
        <div style="text-align:center;padding:20px;color:var(--text2);font-size:13px">
          Kliknij napis na liÅ›cie aby edytowaÄ‡
        </div>
      </div>
    </div>

    <div class="btn-group" style="margin-top:16px">
      <button class="btn btn-outline" onclick="navigateToTab('crop')">â† Wstecz</button>
      <button class="btn btn-success" onclick="saveCaptions(); navigateToTab('transitions')">Zapisz i dalej â†’ PrzejÅ›cia</button>
    </div>
  </div>

  <!-- â•â•â• Tab 6: Transitions / PrzejÅ›cia â•â•â• -->
  <div class="panel" id="panel-transitions">
    <div class="panel-header">
      <h2>PrzejÅ›cia miÄ™dzy klatkami</h2>
      <p>Ustaw efekty przejÅ›Ä‡ miÄ™dzy klatkami â€” fade, pixelize, blur. ZarzÄ…dzaj grupowo lub per klatka.</p>
    </div>

    <div class="transitions-global" id="transitionsGlobal">
      <span style="font-size:13px;font-weight:600;color:var(--text)">Zastosuj do wszystkich:</span>
      <select id="globalTransitionType" style="padding:6px 10px;background:var(--surface2);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px">
        <option value="none">Brak</option>
        <option value="fade">Fade (zanikanie)</option>
        <option value="pixelize">Pixelize (pikselizacja)</option>
        <option value="blur">Blur (rozmycie)</option>
        <option value="slide_left">Slide â† (przesuniÄ™cie)</option>
        <option value="slide_right">Slide â†’ (przesuniÄ™cie)</option>
      </select>
      <input type="range" id="globalTransitionDuration" min="0.1" max="1.0" step="0.1" value="0.3"
             oninput="document.getElementById('globalTransitionDurationVal').textContent=parseFloat(this.value).toFixed(1)+'s'"
             style="width:100px">
      <span id="globalTransitionDurationVal" style="font-size:12px;color:var(--text2);white-space:nowrap">0.3s</span>
      <button class="btn btn-outline" style="padding:6px 14px;font-size:12px" onclick="applyTransitionToAll()">Zastosuj do wszystkich</button>
      <button class="btn btn-outline" style="padding:6px 14px;font-size:12px" onclick="clearAllTransitions()">WyczyÅ›Ä‡</button>
    </div>

    <div id="transitionsGrid" class="transitions-grid">
      <div style="grid-column:1/-1;text-align:center;padding:40px;color:var(--text2);font-size:13px">
        ZaÅ‚aduj sesjÄ™ i przejdÅº tu z zakÅ‚adki Napisy
      </div>
    </div>

    <div class="btn-group">
      <button class="btn btn-outline" onclick="navigateToTab('captions')">â† Wstecz</button>
      <button class="btn btn-primary" onclick="navigateToTab('publish')">Dalej â†’ Publikacja</button>
    </div>
  </div>

  <!-- â•â•â• Tab 7: Publish â•â•â• -->
  <div class="panel" id="panel-publish">
    <div class="panel-header">
      <h2>Eksport i publikacja</h2>
      <p>Eksportuj jako wideo, GIF lub paczkÄ™ PNG, i udostÄ™pnij.</p>
    </div>

    <div class="panel-subtitle" id="publishPresetInfo">Wybrany format: â€”</div>

    <div class="tools-bar">
      <button class="tool-btn success" onclick="exportSession()" title="Eksportuj z aktualnymi ustawieniami">
        <span class="icon">ğŸ“¦</span> Szybki eksport
      </button>
      <button class="tool-btn" onclick="exportAllFormats()" title="Eksportuj we wszystkich formatach">
        <span class="icon">ğŸ“</span> Eksport wszystkich
      </button>
      <button class="tool-btn" onclick="addWatermark()" title="Dodaj znak wodny">
        <span class="icon">ğŸŒ</span> Znak wodny
      </button>
      <button class="tool-btn" onclick="openExportsFolder()" title="OtwÃ³rz folder eksportÃ³w">
        <span class="icon">ğŸ“‚</span> Folder eksportÃ³w
      </button>
      <button class="tool-btn" onclick="copyShareURL()" title="Kopiuj link do sesji">
        <span class="icon">ğŸ”—</span> Kopiuj link
      </button>
      <div class="tools-divider"></div>
      <button class="tool-btn advanced" onclick="advancedVideoExport()" title="FFmpeg zaawansowany (wymaga ffmpeg)">
        <span class="icon">ğŸ§ </span> Zaawansowany eksport
      </button>
    </div>

    <div class="publish-section">

      <!-- Animated frame preview loop -->
      <div id="publishAnimWrap" style="background:var(--bg);border:1px solid var(--border);border-radius:10px;padding:12px;margin-bottom:20px;text-align:center">
        <div style="font-size:12px;color:var(--text2);margin-bottom:8px">
          ğŸ¥ PodglÄ…d animacji &mdash; <span id="publishAnimLabel">pierwsze 3 klatki, loop</span>
        </div>
        <div style="position:relative;display:inline-block;background:#000;border-radius:6px;overflow:hidden;min-width:180px;min-height:100px">
          <img id="publishAnimImg" src="" alt="" style="max-width:100%;max-height:240px;display:block;object-fit:contain">
          <div id="publishAnimSpinner" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.5)">
            <div class="spinner"></div>
          </div>
        </div>
        <div id="publishAnimDots" style="margin-top:8px;display:flex;justify-content:center;gap:6px"></div>
        <div style="margin-top:8px;font-size:11px;color:var(--text2)">
          ğŸ–±ï¸ Kliknij na podglÄ…dzie aby ustawiÄ‡ pozycjÄ™ znaku wodnego
        </div>
      </div>

      <!-- Watermark Configurator -->
      <div class="wm-config">
        <h4 style="display:flex;align-items:center;gap:8px">
          ğŸŒŠ Znak wodny
          <label style="display:flex;align-items:center;gap:6px;font-weight:normal;font-size:12px;cursor:pointer;margin-left:auto">
            <input type="checkbox" id="publishWatermark" onchange="wmToggle()" style="accent-color:var(--accent)">
            WÅ‚Ä…cz
          </label>
        </h4>

        <div id="wmFields" style="display:none">
          <!-- Position preview -->
          <div class="wm-hint">Kliknij na podglÄ…dzie powyÅ¼ej aby ustawiÄ‡ pozycjÄ™, lub wybierz preset:</div>
          <div class="wm-row">
            <label>Pozycja</label>
            <select id="wmPosition" onchange="wmPositionPreset(this.value)">
              <option value="bottom_right">â†˜ Prawy dÃ³Å‚</option>
              <option value="bottom_left">â†™ Lewy dÃ³Å‚</option>
              <option value="top_right">â†— Prawy gÃ³ra</option>
              <option value="top_left">â†– Lewy gÃ³ra</option>
              <option value="center">âŠ• Åšrodek</option>
              <option value="custom">ğŸ“ WÅ‚asna (kliknij)</option>
            </select>
            <span id="wmPosDisplay" style="font-size:11px;color:var(--text2);white-space:nowrap"></span>
          </div>

          <!-- Logo upload -->
          <div class="wm-row">
            <label>Logo</label>
            <input type="file" id="wmLogoFile" accept="image/*" onchange="wmLogoChanged(this)" style="flex:1;font-size:11px">
            <img id="wmLogoPreview" class="wm-logo-preview" style="display:none">
            <button class="wm-transparent-btn" onclick="wmClearLogo()" title="UsuÅ„ logo">âœ•</button>
          </div>
          <div class="wm-row">
            <label>Rozmiar logo</label>
            <input type="range" id="wmLogoSize" min="16" max="256" value="64" step="8"
                   oninput="document.getElementById('wmLogoSizeVal').textContent=this.value+'px'; wmChanged()">
            <span id="wmLogoSizeVal" style="font-size:11px;color:var(--text2);white-space:nowrap">64px</span>
          </div>
          <div class="wm-row">
            <label>Opacity logo</label>
            <input type="range" id="wmLogoOpacity" min="10" max="100" value="80" step="5"
                   oninput="document.getElementById('wmLogoOpacityVal').textContent=this.value+'%'; wmChanged()">
            <span id="wmLogoOpacityVal" style="font-size:11px;color:var(--text2);white-space:nowrap">80%</span>
          </div>

          <!-- Text -->
          <div class="wm-row">
            <label>Tekst</label>
            <input type="text" id="wmText" placeholder="np. example.com" oninput="wmChanged()">
            <input type="color" id="wmTextColor" value="#ffffff" onchange="wmChanged()" title="Kolor tekstu">
          </div>
          <div class="wm-row">
            <label>Rozmiar tekstu</label>
            <input type="range" id="wmFontSize" min="10" max="72" value="18" step="2"
                   oninput="document.getElementById('wmFontSizeVal').textContent=this.value+'px'; wmChanged()">
            <span id="wmFontSizeVal" style="font-size:11px;color:var(--text2);white-space:nowrap">18px</span>
          </div>

          <!-- Background -->
          <div class="wm-row">
            <label>TÅ‚o</label>
            <input type="color" id="wmBgColor" value="#000000" onchange="wmChanged()" title="Kolor tÅ‚a">
            <input type="range" id="wmBgOpacity" min="0" max="100" value="60" step="5"
                   oninput="document.getElementById('wmBgOpacityVal').textContent=this.value+'%'; wmChanged()">
            <span id="wmBgOpacityVal" style="font-size:11px;color:var(--text2);white-space:nowrap">60%</span>
            <button class="wm-transparent-btn" id="wmBgTransparentBtn" onclick="wmSetTransparent()" title="Brak tÅ‚a">Brak tÅ‚a</button>
          </div>

          <button class="btn btn-outline" style="font-size:12px;margin-top:4px" onclick="wmSaveToServer()">
            ğŸ’¾ Zapisz jako branding.json
          </button>
        </div>
      </div>

      <div class="export-options">
        <div class="export-row">
          <label>Czas/klatka:</label>
          <input type="range" id="exportDuration" min="0.1" max="5" value="0.5" step="0.1"
                 oninput="document.getElementById('durationValue').textContent = this.value + 's'; syncConfigToURL(); restartPublishPreview();">
          <span id="durationValue" class="range-value">0.5s</span>
          <div class="range-labels">
            <span>0.1s</span><span>2.5s</span><span>5s</span>
          </div>
        </div>
        <div class="export-row">
          <label>JakoÅ›Ä‡:</label>
          <input type="range" id="exportQuality" min="10" max="100" value="70" step="5"
                 oninput="document.getElementById('qualityValue').textContent = this.value + '%'; syncConfigToURL(); initPublishPreview();">
          <span id="qualityValue" class="range-value">70%</span>
          <div class="range-labels">
            <span>Niska</span><span>Åšrednia</span><span>Wysoka</span>
          </div>
        </div>
        <div class="export-row" style="display:none;">
          <label>FPS:</label>
          <input type="range" id="exportFps" min="1" max="10" value="2" step="1" 
                 oninput="document.getElementById('fpsValue').textContent = this.value">
          <span id="fpsValue" class="range-value">2</span>
          <div class="range-labels">
            <span>1</span><span>5</span><span>10</span>
          </div>
        </div>
      </div>

      <!-- hidden select kept for JS compatibility -->
      <select id="exportFormat" style="display:none"><option value="video">MP4</option></select>

      <button class="btn btn-success" onclick="exportAllFormats()" id="exportBtn">
        âš¡ Generuj wszystkie formaty (MP4, GIF, WebM, ZIP)
      </button>

      <div id="exportResults" style="margin-top:16px;display:none;">
        <h4>Gotowe pliki:</h4>
        <div id="exportLinks" class="export-links"></div>
      </div>

      <h3 style="margin-top:32px; font-size:15px;">UdostÄ™pnij</h3>
      <div class="social-links" id="socialLinks"></div>
    </div>
  </div>

</div>

<div class="toast" id="toast"></div>

<script>
// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentSession = null;
let sessionData = null;
let selectedFrames = new Set();
let centerMarks = {};  // frameIndex -> {x, y}
let currentCenterFrame = 0;
let activePreset = 'twitter_post';
let presets = {};
let duplicateIndices = new Set();  // indices marked as duplicates
let duplicatePairs = [];           // [{frame_a, frame_b, similarity}]
let advancedModeOn = false;
let currentFocusMode = 'mouse';
let currentZoomLevel = 1.0;
let currentMousePadding = 20;
let cropPreviews = {};    // frameIndex -> {filename, w, h} â€” populated by loadCropPreview
let transitions = {};     // frameIndex -> {type, duration} â€” per-frame transition before this frame

// â”€â”€â”€ URL Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function parseURL() {
  const path = window.location.pathname;
  const params = new URLSearchParams(window.location.search);
  
  // Parse session and tab from URL
  if (path.startsWith('/session/')) {
    const parts = path.split('/');
    const sessionName = parts[2];
    const tabName = parts[4] || 'select'; // default to select tab
    
    return { sessionName, tabName };
  }
  
  return { sessionName: null, tabName: 'select' };
}

function updateURL(sessionName = null, tabName = null) {
  let url = '/';
  
  if (sessionName) {
    const params = new URLSearchParams();
    params.set('preset', activePreset || '');
    params.set('focus', currentFocusMode);
    params.set('zoom', String(currentZoomLevel));
    params.set('pad', String(currentMousePadding));
    params.set('dur', document.getElementById('exportDuration')?.value || '0.5');
    params.set('quality', document.getElementById('exportQuality')?.value || '70');
    url = `/session/${sessionName}/tab/${tabName || 'select'}?${params.toString()}`;
  }
  
  window.history.pushState({}, '', url);
}

function syncConfigToURL() {
  if (!currentSession) return;
  const { tabName } = parseURL();
  const params = new URLSearchParams();
  params.set('preset', activePreset || '');
  params.set('focus', currentFocusMode);
  params.set('zoom', String(currentZoomLevel));
  params.set('pad', String(currentMousePadding));
  params.set('dur', document.getElementById('exportDuration')?.value || '0.5');
  params.set('quality', document.getElementById('exportQuality')?.value || '70');
  params.set('centers', String(Object.keys(centerMarks).length));
  params.set('sel', String(selectedFrames.size));
  const url = `/session/${currentSession}/tab/${tabName || 'select'}?${params.toString()}`;
  window.history.replaceState({}, '', url);
}

function navigateToSession(sessionName, tabName = 'select') {
  updateURL(sessionName, tabName);
  loadSession(sessionName);
  if (tabName !== 'select') {
    switchTab(tabName);
  }
}

function navigateToTab(tabName) {
  switchTab(tabName);
  if (currentSession) {
    syncConfigToURL();  // preserves all params including focus/zoom/pad/centers/sel
  }
}

function applyConfigFromURL() {
  const params = new URLSearchParams(window.location.search);
  const preset  = params.get('preset');
  const focus   = params.get('focus');
  const zoom    = params.get('zoom');
  const pad     = params.get('pad');
  const dur     = params.get('dur');
  const quality = params.get('quality');

  // â”€â”€ Preset â”€â”€
  if (preset) {
    activePreset = preset;
    updatePresetBtns();
  }

  // â”€â”€ Focus mode â€” set state + UI without triggering video preview â”€â”€
  if (focus) {
    currentFocusMode = focus;
    const zoomControls = document.getElementById('zoomControls');
    if (zoomControls) zoomControls.style.display = focus === 'mouse' ? 'block' : 'none';
    document.querySelectorAll(`input[name="focusMode"][value="${focus}"], input[name="exportFocusMode"][value="${focus}"]`)
      .forEach(r => { r.checked = true; });
  }

  // â”€â”€ Zoom â”€â”€
  if (zoom) {
    currentZoomLevel = parseFloat(zoom);
    const zv = document.getElementById('zoomValue'); if (zv) zv.textContent = currentZoomLevel.toFixed(1) + 'x';
    const zs = document.getElementById('zoomSlider'); if (zs) zs.value = zoom;
    const ezv = document.getElementById('exportZoomValue'); if (ezv) ezv.textContent = currentZoomLevel.toFixed(1) + 'x';
    const ezs = document.getElementById('exportZoomSlider'); if (ezs) ezs.value = zoom;
  }

  // â”€â”€ Padding â”€â”€
  if (pad) {
    currentMousePadding = parseInt(pad);
    const pv = document.getElementById('paddingValue'); if (pv) pv.textContent = currentMousePadding + '%';
    const ps = document.getElementById('paddingSlider'); if (ps) ps.value = pad;
    const epv = document.getElementById('exportPaddingValue'); if (epv) epv.textContent = currentMousePadding + '%';
    const eps = document.getElementById('exportPaddingSlider'); if (eps) eps.value = pad;
  }

  // â”€â”€ Duration â”€â”€
  if (dur) {
    const el = document.getElementById('exportDuration'); if (el) el.value = dur;
    const lbl = document.getElementById('durationValue'); if (lbl) lbl.textContent = dur + 's';
  }

  // â”€â”€ Quality â”€â”€
  if (quality) {
    const el = document.getElementById('exportQuality'); if (el) el.value = quality;
    const lbl = document.getElementById('qualityValue'); if (lbl) lbl.textContent = quality + '%';
  }

  updatePublishPresetInfo();
}

// â”€â”€â”€ Init â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('DOMContentLoaded', async () => {
  await loadSessions();
  await loadPresets();
  setupDragDrop();
  setupCenterCanvas();
  buildSocialLinks();
  updateTabHandlers();

  document.getElementById('exportDuration')?.addEventListener('input', syncConfigToURL);
  document.getElementById('exportQuality')?.addEventListener('input', syncConfigToURL);
  
  // Handle browser back/forward
  window.addEventListener('popstate', () => {
    const { sessionName, tabName } = parseURL();
    if (sessionName && sessionName !== currentSession) {
      loadSession(sessionName);
    }
    if (tabName) {
      switchTab(tabName);
    }
  });
  
  // Load initial state from URL â€” apply config AFTER session+presets loaded
  const { sessionName, tabName } = parseURL();
  if (sessionName) {
    await loadSession(sessionName);
    applyConfigFromURL();  // re-apply after session loaded (presets now available)
    if (tabName && tabName !== 'select') {
      switchTab(tabName);
    }
  }
});

async function api(path, opts = {}) {
  const res = await fetch('/api' + path, {
    headers: { 'Content-Type': 'application/json' },
    ...opts,
    body: opts.body ? JSON.stringify(opts.body) : undefined,
  });
  if (!res.ok) throw new Error(`API error: ${res.status}`);
  return res.json();
}

// â”€â”€â”€ Sessions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadSessions() {
  const sessions = await api('/sessions');
  const sel = document.getElementById('sessionSelect');
  sel.innerHTML = '<option value="">â€” wybierz sesjÄ™ â€”</option>';
  sessions.forEach(s => {
    const opt = document.createElement('option');
    opt.value = s.name;
    opt.textContent = `${s.name} (${s.frame_count} kl.)`;
    sel.appendChild(opt);
  });
  
  // Auto-load first session if no URL session specified
  const { sessionName } = parseURL();
  if (!sessionName && sessions.length > 0) {
    sel.value = sessions[0].name;
    loadSession(sessions[0].name);
  } else if (sessionName) {
    sel.value = sessionName;
  }
}

async function loadSession(name) {
  if (!name) return;
  currentSession = name;
  sessionData = await api(`/sessions/${name}`);
  document.getElementById('sessionInfo').textContent =
    `${sessionData.frame_count} klatek â€¢ ${sessionData.duration.toFixed(1)}s`;

  // Preserve current tab in URL when loading session
  const { tabName: _currentTab } = parseURL();
  updateURL(name, _currentTab || 'select');

  // Show warning if frames are missing on disk
  const missingBanner = document.getElementById('missingFramesBanner');
  const missing = sessionData._missing_frames || [];
  if (missing.length > 0) {
    missingBanner.style.display = 'flex';
    missingBanner.innerHTML = `
      <span>âš ï¸ <strong>${missing.length} klatek brakuje na dysku</strong> â€” pliki nie zostaÅ‚y zapisane podczas nagrywania:<br>
      <small style="font-family:monospace;opacity:.8">${missing.join(', ')}</small></span>
      <button onclick="document.getElementById('missingFramesBanner').style.display='none'" style="background:none;border:none;color:inherit;cursor:pointer;font-size:18px;margin-left:12px">âœ•</button>
    `;
  } else {
    missingBanner.style.display = 'none';
  }

  // ZaÅ‚aduj zaznaczenie
  const prev = sessionData.selected_frames;
  selectedFrames = new Set(prev || sessionData.frames.map((_, i) => i));

  // ZaÅ‚aduj centra
  centerMarks = {};
  const cc = sessionData.custom_centers || {};
  for (const [k, v] of Object.entries(cc)) {
    centerMarks[parseInt(k)] = v;
  }

  renderFrameGrid();
}

// â”€â”€â”€ Tab 1: Frame Selection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderFrameGrid() {
  const grid = document.getElementById('frameGrid');
  grid.innerHTML = '';
  if (!sessionData) return;

  const missingSet = new Set(sessionData._missing_frames || []);

  sessionData.frames.forEach((f, i) => {
    const isMissing = missingSet.has(f.filename);
    const isDup = duplicateIndices.has(i);
    const card = document.createElement('div');
    card.className = `frame-card${selectedFrames.has(i) ? ' selected' : ''}${isMissing ? ' frame-missing' : ''}${isDup ? ' duplicate' : ''}`;
    card.onclick = () => toggleFrame(i, card);

    // Find best similarity match for this duplicate
    let simLabel = '';
    if (isDup) {
      const pair = duplicatePairs.find(p => p.frame_b === i);
      if (pair) simLabel = `<span class="dup-similarity">${pair.similarity}%</span>`;
    }

    card.innerHTML = isMissing
      ? `
        <div class="frame-missing-overlay">âŒ Brak pliku<br><small>${f.filename}</small></div>
        <div class="check">${selectedFrames.has(i) ? 'âœ“' : ''}</div>
        <button class="del-frame" title="UsuÅ„ klatkÄ™" onclick="event.stopPropagation(); deleteFrame(${i})">âœ•</button>
        <div class="meta"><span>#${i+1} â€¢ ${f.timestamp.toFixed(1)}s</span><span style="color:var(--red)">âš  brak pliku</span></div>
      `
      : `
        <img src="/api/sessions/${currentSession}/frames/${f.filename}" loading="lazy">
        <div class="check">${selectedFrames.has(i) ? 'âœ“' : ''}</div>
        ${simLabel}
        <button class="del-frame" title="UsuÅ„ klatkÄ™" onclick="event.stopPropagation(); deleteFrame(${i})">âœ•</button>
        <div class="meta">
          <span>#${i+1} â€¢ ${f.timestamp.toFixed(1)}s</span>
          <span>Î”${f.change_pct.toFixed(0)}% â€¢ ğŸ–±(${f.mouse_x},${f.mouse_y})</span>
        </div>
      `;
    grid.appendChild(card);
  });
}

function toggleFrame(idx, card) {
  if (selectedFrames.has(idx)) {
    selectedFrames.delete(idx);
    card.classList.remove('selected');
    card.querySelector('.check').textContent = '';
  } else {
    selectedFrames.add(idx);
    card.classList.add('selected');
    card.querySelector('.check').textContent = 'âœ“';
  }
}

function selectAllFrames() {
  sessionData.frames.forEach((_, i) => selectedFrames.add(i));
  renderFrameGrid();
}

function deselectAllFrames() {
  selectedFrames.clear();
  renderFrameGrid();
}

// â”€â”€â”€ Frame Trash â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const frameTrash = [];  // { sessionName, frame, origIdx }

function toggleTrash() {
  document.getElementById('trashSidebar').classList.toggle('open');
}

function updateTrashBadge() {
  const badge = document.getElementById('trashBadge');
  badge.textContent = frameTrash.length;
  badge.classList.toggle('show', frameTrash.length > 0);
}

function renderTrashList() {
  const list = document.getElementById('trashList');
  if (frameTrash.length === 0) {
    list.innerHTML = '<div class="trash-empty-msg">Kosz jest pusty</div>';
    return;
  }
  list.innerHTML = '';
  frameTrash.forEach((item, i) => {
    const el = document.createElement('div');
    el.className = 'trash-item';
    el.innerHTML = `
      <img src="/api/sessions/${item.sessionName}/frames/${item.frame.filename}" onerror="this.style.display='none'">
      <div class="trash-item-info">
        <div class="trash-item-name">#${item.origIdx + 1} â€¢ ${item.frame.filename}</div>
        <div class="trash-item-actions">
          <button class="trash-item-restore" onclick="restoreFrame(${i})">â†© PrzywrÃ³Ä‡</button>
          <button class="trash-item-purge" onclick="purgeFrame(${i})" title="UsuÅ„ trwale">âœ•</button>
        </div>
      </div>
    `;
    list.appendChild(el);
  });
}

function deleteFrame(idx) {
  if (!currentSession || !sessionData) return;
  const f = sessionData.frames[idx];
  if (!f) return;

  // Move to trash (soft delete)
  frameTrash.unshift({ sessionName: currentSession, frame: { ...f }, origIdx: idx });
  updateTrashBadge();

  // Remove from local state
  sessionData.frames.splice(idx, 1);
  sessionData.frame_count = sessionData.frames.length;
  sessionData.frames.forEach((fr, i) => { fr.index = i; });
  selectedFrames = new Set([...selectedFrames].filter(x => x !== idx).map(x => x > idx ? x - 1 : x));
  renderFrameGrid();
  renderTrashList();
  persistFrames();  // save to server
  toast(`Klatka #${idx + 1} w koszu â€” â†© przywrÃ³Ä‡ w koszu`);
}

async function restoreFrame(i) {
  const item = frameTrash.splice(i, 1)[0];
  // Re-insert at original position (or end)
  const insertAt = Math.min(item.origIdx, sessionData.frames.length);
  sessionData.frames.splice(insertAt, 0, item.frame);
  sessionData.frame_count = sessionData.frames.length;
  sessionData.frames.forEach((fr, j) => { fr.index = j; });
  selectedFrames = new Set([...selectedFrames].map(x => x >= insertAt ? x + 1 : x));
  selectedFrames.add(insertAt);
  renderFrameGrid();
  updateTrashBadge();
  renderTrashList();
  await persistFrames();  // save to server
  toast(`Klatka przywrÃ³cona na pozycjÄ™ #${insertAt + 1}`);
}

async function purgeFrame(i) {
  const item = frameTrash.splice(i, 1)[0];
  try {
    await fetch(`/api/sessions/${item.sessionName}/frames/${item.frame.filename}`, { method: 'DELETE' });
  } catch (e) { /* ignore */ }
  updateTrashBadge();
  renderTrashList();
  toast(`Klatka trwale usuniÄ™ta`);
}

async function emptyFrameTrash() {
  await Promise.all(frameTrash.map(item =>
    fetch(`/api/sessions/${item.sessionName}/frames/${item.frame.filename}`, { method: 'DELETE' }).catch(() => {})
  ));
  frameTrash.length = 0;
  updateTrashBadge();
  renderTrashList();
  toast('Kosz oprÃ³Å¼niony');
}

async function persistFrames() {
  if (!currentSession || !sessionData) return;
  try {
    await api(`/sessions/${currentSession}/update-frames`, {
      method: 'POST',
      body: {
        frames: sessionData.frames,
        selected_frames: [...selectedFrames].sort((a, b) => a - b),
      },
    });
  } catch (e) {
    console.error('Failed to persist frames:', e);
  }
}

async function saveSelection() {
  if (!currentSession) return;
  await api(`/sessions/${currentSession}/select`, {
    method: 'POST',
    body: { selected_indices: [...selectedFrames].sort((a, b) => a - b) },
  });
  toast('Zapisano wybÃ³r klatek');
}

// â”€â”€â”€ Tools: Tab 1 (Select) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function detectDuplicates() {
  if (!currentSession) return;
  toast('Szukam duplikatÃ³w...');
  try {
    const res = await api(`/sessions/${currentSession}/similarity?threshold=90`);
    duplicatePairs = res.duplicate_pairs || [];
    duplicateIndices = new Set(res.duplicate_indices || []);

    const badge = document.getElementById('dupCount');
    const btn = document.getElementById('btnRemoveDups');
    if (duplicateIndices.size > 0) {
      badge.textContent = duplicateIndices.size;
      badge.style.display = 'inline-block';
      btn.style.display = '';
      toast(`Znaleziono ${duplicateIndices.size} duplikatÃ³w (${duplicatePairs.length} par â‰¥90%)`);
    } else {
      badge.style.display = 'none';
      btn.style.display = 'none';
      toast('Brak duplikatÃ³w â€” wszystkie klatki sÄ… unikalne âœ…');
    }
    renderFrameGrid();
  } catch (e) {
    toast('BÅ‚Ä…d analizy podobieÅ„stwa: ' + e.message);
  }
}

function removeDuplicates() {
  if (duplicateIndices.size === 0) return;
  const toRemove = [...duplicateIndices].sort((a, b) => b - a);
  toRemove.forEach(idx => deleteFrame(idx));
  duplicateIndices.clear();
  duplicatePairs = [];
  document.getElementById('dupCount').style.display = 'none';
  document.getElementById('btnRemoveDups').style.display = 'none';
  toast(`UsuniÄ™to ${toRemove.length} duplikatÃ³w do kosza`);
}

function sortByChange() {
  if (!sessionData) return;
  const sorted = sessionData.frames.slice().sort((a, b) => b.change_pct - a.change_pct);
  const origOrder = sessionData.frames.map(f => f.filename);
  sessionData.frames = sorted;
  sessionData.frames.forEach((f, i) => { f.index = i; });
  selectedFrames = new Set(sessionData.frames.map((_, i) => i));
  renderFrameGrid();
  toast('Posortowano wg % zmiany (malejÄ…co)');
}

function invertSelection() {
  if (!sessionData) return;
  const newSel = new Set();
  sessionData.frames.forEach((_, i) => {
    if (!selectedFrames.has(i)) newSel.add(i);
  });
  selectedFrames = newSel;
  renderFrameGrid();
  toast(`OdwrÃ³cono zaznaczenie â€” ${selectedFrames.size} zaznaczonych`);
}

function selectEveryNth() {
  const n = parseInt(prompt('Zaznacz co ktÃ³rÄ… klatkÄ™? (np. 2 = co drugÄ…)', '2'));
  if (!n || n < 1 || !sessionData) return;
  selectedFrames.clear();
  sessionData.frames.forEach((_, i) => {
    if (i % n === 0) selectedFrames.add(i);
  });
  renderFrameGrid();
  toast(`Zaznaczono co ${n}. klatkÄ™ â€” ${selectedFrames.size} zaznaczonych`);
}

function selectMostDifferent() {
  if (!sessionData) return;
  
  // Sort frames by change_pct (descending)
  const framesWithIndex = sessionData.frames.map((frame, index) => ({
    index,
    change_pct: frame.change_pct || 0
  }));
  
  framesWithIndex.sort((a, b) => b.change_pct - a.change_pct);
  
  // Calculate threshold based on distribution
  const changes = framesWithIndex.map(f => f.change_pct);
  const avgChange = changes.reduce((a, b) => a + b, 0) / changes.length;
  const maxChange = Math.max(...changes);
  
  // Select frames with change > average + 25% of (max - average)
  // This captures the top ~25% most changing frames
  const threshold = avgChange + (maxChange - avgChange) * 0.25;
  
  selectedFrames.clear();
  framesWithIndex.forEach(frame => {
    if (frame.change_pct >= threshold) {
      selectedFrames.add(frame.index);
    }
  });
  
  // Always include first frame (usually important)
  selectedFrames.add(0);
  
  renderFrameGrid();
  toast(`Zaznaczono ${selectedFrames.size} klatek z najwiÄ™kszymi zmianami (>${threshold.toFixed(1)}%)`);
}

function selectFirstN() {
  const n = parseInt(prompt('Ile pierwszych klatek zaznaczyÄ‡?', '5'));
  if (!n || n < 1 || !sessionData) return;
  selectedFrames.clear();
  for (let i = 0; i < Math.min(n, sessionData.frames.length); i++) selectedFrames.add(i);
  renderFrameGrid();
  toast(`Zaznaczono pierwsze ${selectedFrames.size} klatek`);
}

function selectTimeRange() {
  if (!sessionData) return;
  const dur = sessionData.duration || sessionData.frames.length;
  const range = prompt(`Zakres czasu w sekundach (np. "2-8" z ${dur.toFixed(1)}s)`, `0-${Math.ceil(dur)}`);
  if (!range) return;
  const [from, to] = range.split('-').map(Number);
  if (isNaN(from) || isNaN(to)) { toast('NieprawidÅ‚owy zakres'); return; }
  selectedFrames.clear();
  sessionData.frames.forEach((f, i) => {
    const t = f.timestamp || i;
    if (t >= from && t <= to) selectedFrames.add(i);
  });
  renderFrameGrid();
  toast(`Zaznaczono ${selectedFrames.size} klatek z zakresu ${from}-${to}s`);
}

// â”€â”€â”€ Tab 2: Annotations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let annTool = 'arrow';       // 'arrow' | 'rect' | 'text'
let annColor = '#fc5c7c';
let annDrawing = false;
let annStartX = 0, annStartY = 0;
let annCurrentFrame = null;
// annotations[frameIndex] = [ {type, color, lineWidth, x1,y1,x2,y2, text?} ]
let annotations = {};
let annBgImage = null;       // current background Image object

function setAnnotateTool(tool) {
  annTool = tool;
  ['annToolArrow','annToolRect','annToolText'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.toggle('success', id === 'annTool' + tool.charAt(0).toUpperCase() + tool.slice(1));
  });
}

function setAnnotateColor(color, btn) {
  annColor = color;
  document.querySelectorAll('.annotate-color-btn').forEach(b => b.classList.remove('active'));
  if (btn) btn.classList.add('active');
}

function renderAnnotatePanel() {
  if (!sessionData) return;
  const list = document.getElementById('annotateFrameList');
  list.innerHTML = '';
  const selected = [...selectedFrames].sort((a, b) => a - b);

  selected.forEach((idx, i) => {
    const f = sessionData.frames[idx];
    const thumb = document.createElement('div');
    const hasAnn = annotations[idx] && annotations[idx].length > 0;
    thumb.className = `annotate-thumb${i === 0 && annCurrentFrame === null ? ' active' : ''}${annCurrentFrame === idx ? ' active' : ''}`;
    thumb.onclick = () => showAnnotateFrame(idx);
    thumb.innerHTML = `
      <img src="/api/sessions/${currentSession}/frames/${f.filename}">
      <span class="idx">#${idx+1} ${hasAnn ? 'âœï¸' : ''}</span>
    `;
    list.appendChild(thumb);
  });

  if (selected.length > 0 && annCurrentFrame === null) showAnnotateFrame(selected[0]);
}

function showAnnotateFrame(idx) {
  annCurrentFrame = idx;
  const f = sessionData.frames[idx];
  const canvas = document.getElementById('annotateCanvas');
  const ctx = canvas.getContext('2d');

  const img = new Image();
  img.crossOrigin = 'anonymous';
  img.onload = () => {
    canvas.width = img.naturalWidth;
    canvas.height = img.naturalHeight;
    annBgImage = img;
    redrawAnnotations();
  };
  img.src = `/api/sessions/${currentSession}/frames/${f.filename}`;

  // Highlight thumb
  document.querySelectorAll('.annotate-thumb').forEach(t => t.classList.remove('active'));
  const thumbs = document.querySelectorAll('.annotate-thumb');
  const selected = [...selectedFrames].sort((a, b) => a - b);
  const ti = selected.indexOf(idx);
  if (ti >= 0 && thumbs[ti]) thumbs[ti].classList.add('active');
}

function redrawAnnotations() {
  const canvas = document.getElementById('annotateCanvas');
  const ctx = canvas.getContext('2d');
  if (annBgImage) {
    ctx.drawImage(annBgImage, 0, 0);
  }
  const items = annotations[annCurrentFrame] || [];
  items.forEach(a => drawAnnotation(ctx, a));
}

function drawAnnotation(ctx, a) {
  ctx.strokeStyle = a.color;
  ctx.fillStyle = a.color;
  ctx.lineWidth = a.lineWidth;
  ctx.lineCap = 'round';

  if (a.type === 'arrow') {
    // Line
    ctx.beginPath();
    ctx.moveTo(a.x1, a.y1);
    ctx.lineTo(a.x2, a.y2);
    ctx.stroke();
    // Arrowhead
    const angle = Math.atan2(a.y2 - a.y1, a.x2 - a.x1);
    const headLen = Math.max(a.lineWidth * 5, 16);
    ctx.beginPath();
    ctx.moveTo(a.x2, a.y2);
    ctx.lineTo(a.x2 - headLen * Math.cos(angle - 0.4), a.y2 - headLen * Math.sin(angle - 0.4));
    ctx.lineTo(a.x2 - headLen * Math.cos(angle + 0.4), a.y2 - headLen * Math.sin(angle + 0.4));
    ctx.closePath();
    ctx.fill();
  } else if (a.type === 'rect') {
    ctx.lineWidth = a.lineWidth;
    ctx.strokeRect(a.x1, a.y1, a.x2 - a.x1, a.y2 - a.y1);
    // Light fill for highlight effect
    ctx.fillStyle = a.color + '18';
    ctx.fillRect(a.x1, a.y1, a.x2 - a.x1, a.y2 - a.y1);
  } else if (a.type === 'text') {
    const fontSize = Math.max(a.lineWidth * 8, 20);
    ctx.font = `bold ${fontSize}px sans-serif`;
    ctx.fillStyle = a.color;
    ctx.shadowColor = 'rgba(0,0,0,0.6)';
    ctx.shadowBlur = 4;
    ctx.fillText(a.text, a.x1, a.y1);
    ctx.shadowBlur = 0;
  }
}

function getCanvasCoords(e) {
  const canvas = document.getElementById('annotateCanvas');
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  return {
    x: Math.round((e.clientX - rect.left) * scaleX),
    y: Math.round((e.clientY - rect.top) * scaleY),
  };
}

function setupAnnotateCanvas() {
  const canvas = document.getElementById('annotateCanvas');

  canvas.addEventListener('mousedown', (e) => {
    if (annCurrentFrame === null) return;
    const { x, y } = getCanvasCoords(e);
    annDrawing = true;
    annStartX = x;
    annStartY = y;

    if (annTool === 'text') {
      annDrawing = false;
      const text = prompt('Wpisz tekst:', '');
      if (!text) return;
      if (!annotations[annCurrentFrame]) annotations[annCurrentFrame] = [];
      annotations[annCurrentFrame].push({
        type: 'text', color: annColor,
        lineWidth: parseInt(document.getElementById('annLineWidth').value),
        x1: x, y1: y, x2: x, y2: y, text,
      });
      redrawAnnotations();
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!annDrawing || annTool === 'text') return;
    const { x, y } = getCanvasCoords(e);
    // Live preview
    redrawAnnotations();
    const ctx = canvas.getContext('2d');
    const lw = parseInt(document.getElementById('annLineWidth').value);
    drawAnnotation(ctx, {
      type: annTool, color: annColor, lineWidth: lw,
      x1: annStartX, y1: annStartY, x2: x, y2: y,
    });
  });

  canvas.addEventListener('mouseup', (e) => {
    if (!annDrawing || annTool === 'text') return;
    annDrawing = false;
    const { x, y } = getCanvasCoords(e);
    const lw = parseInt(document.getElementById('annLineWidth').value);
    if (!annotations[annCurrentFrame]) annotations[annCurrentFrame] = [];
    annotations[annCurrentFrame].push({
      type: annTool, color: annColor, lineWidth: lw,
      x1: annStartX, y1: annStartY, x2: x, y2: y,
    });
    redrawAnnotations();
  });

  canvas.addEventListener('mouseleave', () => {
    if (annDrawing && annTool !== 'text') {
      annDrawing = false;
      redrawAnnotations();
    }
  });
}

function undoAnnotation() {
  if (annCurrentFrame === null) return;
  const items = annotations[annCurrentFrame];
  if (!items || items.length === 0) { toast('Brak adnotacji do cofniÄ™cia'); return; }
  items.pop();
  redrawAnnotations();
  toast('CofniÄ™to adnotacjÄ™');
}

function clearAnnotations() {
  if (annCurrentFrame === null) return;
  annotations[annCurrentFrame] = [];
  redrawAnnotations();
  toast('Wyczyszczono adnotacje na tej klatce');
}

function saveAnnotations() {
  // Annotations are saved as rendered PNGs onto the frame images
  // For now, store in memory â€” actual baking happens at export
  toast(`Zapisano adnotacje dla ${Object.keys(annotations).filter(k => annotations[k]?.length > 0).length} klatek`);
}

// Init annotation canvas on DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
  setupAnnotateCanvas();
});

// â”€â”€â”€ Export Focus Mode Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateExportFocusMode(mode) {
  currentFocusMode = mode;
  const zoomControls = document.getElementById('exportZoomControls');
  zoomControls.style.display = mode === 'mouse' ? 'block' : 'none';
  
  // Sync with crop tab
  document.querySelector('input[name="focusMode"][value="' + mode + '"]').checked = true;
  
  // Update video preview
  updateVideoPreview();
  
  toast(`Tryb focusu eksportu: ${mode === 'screen' ? 'Ekran' : mode === 'mouse' ? 'Mysz' : mode === 'keyboard' ? 'Klawiatura' : 'Aplikacja'}`);
}

function updateExportZoom(value) {
  currentZoomLevel = parseFloat(value);
  document.getElementById('exportZoomValue').textContent = currentZoomLevel.toFixed(1) + 'x';
  
  // Sync with crop tab
  document.getElementById('zoomSlider').value = value;
  document.getElementById('zoomValue').textContent = currentZoomLevel.toFixed(1) + 'x';
  
  // Update video preview
  updateVideoPreview();
}

function updateExportPadding(value) {
  currentMousePadding = parseInt(value);
  document.getElementById('exportPaddingValue').textContent = currentMousePadding + 'px';
  
  // Sync with crop tab
  document.getElementById('paddingSlider').value = value;
  document.getElementById('paddingValue').textContent = currentMousePadding + 'px';
  
  // Update video preview
  updateVideoPreview();
}

// â”€â”€â”€ Video Preview Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let videoPreviewTimeout = null;

function updateVideoPreview() {
  // Clear previous timeout
  if (videoPreviewTimeout) {
    clearTimeout(videoPreviewTimeout);
  }
  
  // Debounce preview generation
  videoPreviewTimeout = setTimeout(() => {
    generateVideoPreview('crop');
  }, 500);
}

async function generateVideoPreview(context) {
  if (!currentSession || !sessionData) return;
  
  const previewId = 'videoPreview';
  const previewEl = document.getElementById(previewId);
  
  if (!previewEl) return;
  
  // Show loading state
  previewEl.innerHTML = `
    <div style="color:var(--text2);font-size:12px;text-align:center">
      <div class="spinner" style="margin:0 auto 8px auto"></div>
      <div>Generowanie podglÄ…du...</div>
      <small style="display:block;margin-top:4px">${currentFocusMode === 'mouse' ? `Zoom ${currentZoomLevel}x â€¢ obszar ${currentMousePadding}px` : currentFocusMode}</small>
    </div>
  `;
  
  try {
    const result = await api(`/sessions/${currentSession}/video-preview`, {
      method: 'POST',
      body: {
        preset: activePreset,
        frame_indices: [...selectedFrames].sort((a, b) => a - b),
        focus_mode: currentFocusMode,
        zoom_level: currentZoomLevel,
        mouse_padding: currentMousePadding,
        custom_centers: Object.fromEntries(Object.entries(centerMarks).map(([k,v]) => [k, {x: v.x, y: v.y}])),
      },
    });
    
    const focusIcon = result.focus_mode === 'mouse' ? 'ğŸ–±ï¸' : 
                      result.focus_mode === 'keyboard' ? 'âŒ¨ï¸' : 
                      result.focus_mode === 'application' ? 'ğŸª¬' : 'ğŸ–¥ï¸';
    
    previewEl.innerHTML = `
      <div style="display:flex;flex-direction:column;align-items:center;gap:8px;width:100%">
        <img src="${result.preview_url}?t=${Date.now()}" style="max-width:100%;max-height:200px;border-radius:4px;box-shadow:0 2px 8px rgba(0,0,0,0.1)">
        <div style="font-size:11px;color:var(--text2);text-align:center;line-height:1.4">
          <div><strong>Klatka #${result.frame_index + 1}</strong> â€¢ ${focusIcon} ${result.focus_mode}</div>
          ${result.focus_mode === 'mouse' ? `<div>Zoom ${result.zoom_level}x â€¢ obszar ${currentMousePadding}px</div>` : ''}
          <div>WyciÄ™to: ${result.crop.w}Ã—${result.crop.h}px â†’ ${result.target.w}Ã—${result.target.h}px</div>
          <div>Åšrodek: (${result.center.x}, ${result.center.y})</div>
        </div>
      </div>
    `;
  } catch (e) {
    previewEl.innerHTML = `
      <div style="color:var(--red);font-size:12px;text-align:center">
        <div>âŒ BÅ‚Ä…d generowania podglÄ…du</div>
        <small style="display:block;margin-top:4px">${e.message}</small>
      </div>
    `;
  }
}

// â”€â”€â”€ Focus Mode & Zoom Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateFocusMode(mode) {
  currentFocusMode = mode;
  const zoomControls = document.getElementById('zoomControls');
  if (zoomControls) zoomControls.style.display = mode === 'mouse' ? 'block' : 'none';
  // Sync radio buttons (both focusMode and exportFocusMode groups)
  document.querySelectorAll(`input[name="focusMode"][value="${mode}"], input[name="exportFocusMode"][value="${mode}"]`)
    .forEach(r => { r.checked = true; });
  // Auto-refresh crop preview if on crop tab
  const cropPanel = document.getElementById('panel-crop');
  if (cropPanel && cropPanel.classList.contains('active')) loadCropPreview();
  updateVideoPreview();
  toast(`Tryb focusu: ${mode === 'screen' ? 'Ekran' : mode === 'mouse' ? 'Mysz' : mode === 'keyboard' ? 'Klawiatura' : 'Aplikacja'}`);
}

function updateZoom(value) {
  currentZoomLevel = parseFloat(value);
  const zv = document.getElementById('zoomValue');
  if (zv) zv.textContent = currentZoomLevel.toFixed(1) + 'x';
  const ezs = document.getElementById('exportZoomSlider');
  if (ezs) ezs.value = value;
  const ezv = document.getElementById('exportZoomValue');
  if (ezv) ezv.textContent = currentZoomLevel.toFixed(1) + 'x';
  const cropPanel = document.getElementById('panel-crop');
  if (cropPanel && cropPanel.classList.contains('active')) loadCropPreview();
  updateVideoPreview();
}

function updatePadding(value) {
  currentMousePadding = parseInt(value);
  const pv = document.getElementById('paddingValue');
  if (pv) pv.textContent = currentMousePadding + '%';
  const eps = document.getElementById('exportPaddingSlider');
  if (eps) eps.value = value;
  const epv = document.getElementById('exportPaddingValue');
  if (epv) epv.textContent = currentMousePadding + '%';
  const cropPanel = document.getElementById('panel-crop');
  if (cropPanel && cropPanel.classList.contains('active')) loadCropPreview();
  updateVideoPreview();
}

// â”€â”€â”€ Advanced Mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function toggleAdvancedMode(on) {
  advancedModeOn = on;
  document.querySelectorAll('.tool-btn.advanced').forEach(btn => {
    btn.style.display = on ? '' : 'none';
  });
}

// â”€â”€â”€ Init advanced mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.addEventListener('DOMContentLoaded', () => {
  toggleAdvancedMode(false);
});

// â”€â”€â”€ Mouse Position Matrix (removed â€” replaced by center-grid) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderMouseMatrix() { /* no-op: replaced by renderCenterPanel grid */ }

// â”€â”€â”€ Tab 3: Center Marking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupCenterCanvas() {
  // â”€â”€ Keyboard shortcuts â”€â”€
  document.addEventListener('keydown', (e) => {
    // Only active when center panel is visible
    const panel = document.getElementById('panel-center');
    if (!panel || !panel.classList.contains('active')) return;
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

    const selected = [...selectedFrames].sort((a, b) => a - b);
    const curIdx = selected.indexOf(currentCenterFrame);

    switch (e.key) {
      case 'ArrowRight':
      case 'ArrowDown':
        e.preventDefault();
        if (curIdx < selected.length - 1) showCenterFrame(selected[curIdx + 1]);
        break;
      case 'ArrowLeft':
      case 'ArrowUp':
        e.preventDefault();
        if (curIdx > 0) showCenterFrame(selected[curIdx - 1]);
        break;
      case ' ':  // Space = accept suggestion (mouse cursor position)
        e.preventDefault();
        {
          const f = sessionData.frames[currentCenterFrame];
          const sx = f.suggested_center_x || Math.round(f.width / 2);
          const sy = f.suggested_center_y || Math.round(f.height / 2);
          setCenter(currentCenterFrame, sx, sy);
          // Auto-advance to next frame
          if (curIdx < selected.length - 1) {
            setTimeout(() => showCenterFrame(selected[curIdx + 1]), 150);
          }
        }
        break;
      case 'c':
      case 'C':  // C = copy center from previous frame
        e.preventDefault();
        if (curIdx > 0) {
          const prev = centerMarks[selected[curIdx - 1]];
          if (prev) {
            setCenter(currentCenterFrame, prev.x, prev.y);
            // Auto-advance
            if (curIdx < selected.length - 1) {
              setTimeout(() => showCenterFrame(selected[curIdx + 1]), 150);
            }
          } else {
            toast('Poprzednia klatka nie ma oznaczonego Å›rodka');
          }
        }
        break;
      case 'Enter':  // Enter = next tab
        e.preventDefault();
        saveCenters();
        navigateToTab('crop');
        break;
      case 'Escape':
        e.preventDefault();
        navigateToTab('select');
        break;
    }
  });
}

function renderCenterPanel() {
  if (!sessionData) return;
  const grid = document.getElementById('centerGrid');
  grid.innerHTML = '';
  const selected = [...selectedFrames].sort((a, b) => a - b);

  selected.forEach((idx) => {
    const f = sessionData.frames[idx];
    const isMarked = centerMarks[idx] != null;
    const mark = centerMarks[idx];
    const sugX = f.suggested_center_x || Math.round(f.width / 2);
    const sugY = f.suggested_center_y || Math.round(f.height / 2);

    const card = document.createElement('div');
    card.className = `center-grid-card${isMarked ? ' marked' : ''}${idx === currentCenterFrame ? ' active' : ''}`;
    card.id = `cgc-${idx}`;

    // Dot positions as %
    const markXpct = mark ? (mark.x / f.width * 100).toFixed(2) : null;
    const markYpct = mark ? (mark.y / f.height * 100).toFixed(2) : null;
    const sugXpct  = (sugX / f.width * 100).toFixed(2);
    const sugYpct  = (sugY / f.height * 100).toFixed(2);

    card.innerHTML = `
      <div class="cgc-img-wrap" id="cgc-wrap-${idx}">
        <img src="/api/sessions/${currentSession}/frames/${f.filename}" loading="lazy">
        ${mark ? `<div class="cgc-dot user" style="left:${markXpct}%;top:${markYpct}%"></div>` : ''}
        <div class="cgc-dot mouse" id="cgc-sug-${idx}" style="left:${sugXpct}%;top:${sugYpct}%"></div>
      </div>
      <div class="cgc-label">
        <b>#${idx + 1}</b>
        <span id="cgc-info-${idx}">${mark ? `ğŸŸ¢ (${mark.x}, ${mark.y})` : `ğŸ”´ sug (${sugX}, ${sugY})`}</span>
      </div>
    `;

    // Click on image â†’ set focus point
    card.querySelector('.cgc-img-wrap').addEventListener('click', (e) => {
      const wrap = e.currentTarget;
      const img  = wrap.querySelector('img');
      const rect = img.getBoundingClientRect();
      const scaleX = f.width  / rect.width;
      const scaleY = f.height / rect.height;
      const x = Math.round((e.clientX - rect.left)  * scaleX);
      const y = Math.round((e.clientY - rect.top)   * scaleY);
      currentCenterFrame = idx;
      setCenter(idx, x, y);
    });

    grid.appendChild(card);
  });

  updateCenterGridStatus();
}

function updateCenterGridStatus() {
  const marked = Object.keys(centerMarks).length;
  const total  = selectedFrames.size;
  const el = document.getElementById('centerGridStatus');
  if (el) el.textContent = `${marked}/${total} klatek z fokusem`;
}

function showCenterFrame(idx) {
  // Highlight active card in grid
  document.querySelectorAll('.center-grid-card').forEach(c => c.classList.remove('active'));
  const card = document.getElementById(`cgc-${idx}`);
  if (card) {
    card.classList.add('active');
    card.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  }
  currentCenterFrame = idx;
}

function setCenter(idx, x, y) {
  const f = sessionData.frames[idx];
  centerMarks[idx] = { x, y };

  // Update the card in-place
  const card = document.getElementById(`cgc-${idx}`);
  if (card) {
    card.classList.add('marked');
    card.classList.add('active');

    // Remove old user dot if any, add new one
    card.querySelectorAll('.cgc-dot.user').forEach(d => d.remove());
    const wrap = card.querySelector('.cgc-img-wrap');
    const dot = document.createElement('div');
    dot.className = 'cgc-dot user';
    dot.style.left = (x / f.width * 100).toFixed(2) + '%';
    dot.style.top  = (y / f.height * 100).toFixed(2) + '%';
    wrap.appendChild(dot);

    // Update label
    const info = document.getElementById(`cgc-info-${idx}`);
    if (info) info.textContent = `ğŸŸ¢ (${x}, ${y})`;
  }

  updateCenterGridStatus();
  toast(`Fokus klatki #${idx+1}: (${x}, ${y})`);
}

function updateCenterDot() { /* no-op: replaced by inline grid dots */ }

function autoCenters() {
  [...selectedFrames].forEach(idx => {
    const f = sessionData.frames[idx];
    if (!centerMarks[idx]) {
      centerMarks[idx] = {
        x: f.suggested_center_x || f.mouse_x || Math.round(f.width / 2),
        y: f.suggested_center_y || f.mouse_y || Math.round(f.height / 2),
      };
    }
  });
  renderCenterPanel();
  toast('Auto-Å›rodki ustawione na pozycji kursora');
}

async function saveCenters() {
  if (!currentSession) return;
  const marks = Object.entries(centerMarks).map(([k, v]) => ({
    frame_index: parseInt(k), center_x: v.x, center_y: v.y,
  }));
  await api(`/sessions/${currentSession}/centers`, {
    method: 'POST',
    body: { marks },
  });
  toast('Zapisano Å›rodki');
}

function interpolateCenters() {
  const selected = [...selectedFrames].sort((a, b) => a - b);
  const marked = selected.filter(i => centerMarks[i]);
  if (marked.length < 2) { toast('Potrzebujesz co najmniej 2 oznaczonych klatek do interpolacji'); return; }
  let filled = 0;
  for (let m = 0; m < marked.length - 1; m++) {
    const a = marked[m], b = marked[m + 1];
    const ca = centerMarks[a], cb = centerMarks[b];
    const between = selected.filter(i => i > a && i < b && !centerMarks[i]);
    between.forEach(i => {
      const t = (i - a) / (b - a);
      centerMarks[i] = { x: Math.round(ca.x + (cb.x - ca.x) * t), y: Math.round(ca.y + (cb.y - ca.y) * t) };
      filled++;
    });
  }
  renderCenterPanel();
  toast(`Interpolowano ${filled} brakujÄ…cych Å›rodkÃ³w`);
}

function clearAllCenters() {
  if (!confirm('UsunÄ…Ä‡ wszystkie oznaczone Å›rodki?')) return;
  centerMarks = {};
  renderCenterPanel();
  toast('Åšrodki wyczyszczone');
}

function centerToMiddle() {
  [...selectedFrames].forEach(idx => {
    const f = sessionData.frames[idx];
    centerMarks[idx] = { x: Math.round(f.width / 2), y: Math.round(f.height / 2) };
  });
  renderCenterPanel();
  toast('Åšrodki ustawione na Å›rodek obrazu');
}

function copyCenterToAll() {
  const cur = centerMarks[currentCenterFrame];
  if (!cur) { toast('Najpierw ustaw Å›rodek na bieÅ¼Ä…cej klatce'); return; }
  [...selectedFrames].forEach(idx => { centerMarks[idx] = { ...cur }; });
  renderCenterPanel();
  toast(`Skopiowano (${cur.x}, ${cur.y}) do ${selectedFrames.size} klatek`);
}

// â”€â”€â”€ Tab 3: Crop Preview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function loadPresets() {
  presets = await api('/presets');
  renderPresetBars();
  updatePublishPresetInfo();
}

function renderPresetBars() {
  const bar = document.getElementById('presetBar');
  bar.innerHTML = '';
  for (const [key, p] of Object.entries(presets)) {
    const btn = document.createElement('button');
    btn.className = `preset-btn${key === activePreset ? ' active' : ''}`;
    btn.textContent = p.label;
    btn.dataset.preset = key;
    btn.onclick = () => { activePreset = key; updatePresetBtns(); loadCropPreview(); };
    bar.appendChild(btn);
  }
}

function updatePresetBtns() {
  document.querySelectorAll('#presetBar .preset-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.preset === activePreset);
  });
  updatePublishPresetInfo();
}

function updatePublishPresetInfo() {
  const info = document.getElementById('publishPresetInfo');
  if (!info || !presets[activePreset]) return;
  const preset = presets[activePreset];
  info.textContent = `Wybrany format: ${preset.label} (${preset.w}Ã—${preset.h})`;
}

async function loadCropPreview() {
  if (!currentSession) return;
  const grid = document.getElementById('cropPreviewGrid');
  grid.innerHTML = '<div class="spinner"></div>';

  const result = await api(`/sessions/${currentSession}/crop-preview`, {
    method: 'POST',
    body: {
      preset: activePreset,
      frame_indices: [...selectedFrames].sort((a, b) => a - b),
      focus_mode: currentFocusMode,
      zoom_level: currentZoomLevel,
      mouse_padding: currentMousePadding,
      custom_centers: Object.fromEntries(Object.entries(centerMarks).map(([k,v]) => [k, {x: v.x, y: v.y}])),
    },
  });

  cropPreviews = {};
  result.previews.forEach(p => { cropPreviews[p.index] = p; });

  const cacheBust = Date.now();
  grid.innerHTML = '';
  result.previews.forEach(p => {
    const card = document.createElement('div');
    card.className = 'crop-card';
    
    const focusIcon = p.focus_mode === 'mouse' ? 'ğŸ–±ï¸' : 
                      p.focus_mode === 'keyboard' ? 'âŒ¨ï¸' : 
                      p.focus_mode === 'application' ? 'ğŸª¬' : 'ğŸ–¥ï¸';
    
    card.innerHTML = `
      <img src="/api/sessions/${currentSession}/preview/${p.filename}?t=${cacheBust}" loading="lazy">
      <div class="info">
        Klatka #${p.index+1} â€¢ ${focusIcon} ${p.focus_mode} â€¢ zoom: ${p.zoom_level}x<br>
        Å›rodek: (${p.center.x}, ${p.center.y}) â€¢ ${p.target.w}Ã—${p.target.h}
      </div>
    `;
    grid.appendChild(card);
  });
}

async function exportSession() {
  if (!currentSession) return;
  
  const format = document.getElementById('exportFormat').value;
  const btn = document.getElementById('exportBtn');
  const originalHtml = btn.innerHTML;
  btn.innerHTML = '<span class="spinner"></span>GenerujÄ™...';
  btn.disabled = true;

  try {
    const result = await api(`/sessions/${currentSession}/export`, {
      method: 'POST',
      body: {
        preset: activePreset,
        format: format,
        duration_per_frame: parseFloat(document.getElementById('exportDuration').value),
        fps: Math.round(1 / parseFloat(document.getElementById('exportDuration').value)),
        quality: parseInt(document.getElementById('exportQuality').value),
        frame_indices: [...selectedFrames].sort((a, b) => a - b),
        focus_mode: currentFocusMode,
        zoom_level: currentZoomLevel,
        mouse_padding: currentMousePadding,
      },
    });

    // Show result in export results section
    document.getElementById('exportResults').style.display = 'block';
    const linksContainer = document.getElementById('exportLinks');
    
    // Check if preview already exists
    let existingPreview = document.querySelector(`[data-format-link="${format}"]`);
    if (!existingPreview) {
      existingPreview = document.createElement('div');
      existingPreview.className = 'export-preview';
      existingPreview.dataset.formatLink = format;
      linksContainer.appendChild(existingPreview);
    }
    
    // Create preview element based on format
    let previewElement = '';
    if (format === 'zip') {
      previewElement = `<div class="preview-icon">ğŸ“</div>`;
    } else {
      const isVideo = ['video', 'webm'].includes(format);
      const tag = isVideo ? 'video' : 'img';
      const extraAttrs = isVideo ? 'controls muted loop autoplay' : '';
      previewElement = `<${tag} src="${result.download_url}" ${extraAttrs} class="preview-media"></${tag}>`;
    }
    
    existingPreview.innerHTML = `
      <div class="preview-header">
        <span class="format-badge">${format.toUpperCase()}</span>
        <a href="${result.download_url}" download class="download-link">â¬‡ ${result.filename} (${result.size_mb} MB)</a>
      </div>
      <div class="preview-content">
        ${previewElement}
      </div>
    `;
    
    toast(`Eksport ${format.toUpperCase()} gotowy!`);
  } catch (e) {
    toast('BÅ‚Ä…d eksportu: ' + e.message);
  } finally {
    btn.innerHTML = originalHtml;
    btn.disabled = false;
  }
}

// â”€â”€â”€ Publish: Animated Frame Preview Loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _publishAnimFrames = [];   // array of img src URLs (crop previews)
let _publishAnimIdx = 0;
let _publishAnimTimer = null;

async function initPublishPreview() {
  if (!currentSession || !sessionData) return;

  const img = document.getElementById('publishAnimImg');
  const spinner = document.getElementById('publishAnimSpinner');
  const dots = document.getElementById('publishAnimDots');
  const label = document.getElementById('publishAnimLabel');

  spinner.style.display = 'flex';
  _publishAnimFrames = [];
  stopPublishPreview();

  // Pick up to 3 selected frames
  const sel = [...selectedFrames].sort((a, b) => a - b).slice(0, 3);
  if (sel.length === 0) { spinner.style.display = 'none'; return; }

  const useWatermark = document.getElementById('publishWatermark')?.checked || false;
  const quality = parseInt(document.getElementById('exportQuality')?.value || '70');
  label.textContent = `${sel.length} klatek, loop${useWatermark ? ' ğŸŒŠ' : ''}`;

  try {
    const result = await api(`/sessions/${currentSession}/crop-preview`, {
      method: 'POST',
      body: {
        preset: activePreset,
        frame_indices: sel,
        focus_mode: currentFocusMode,
        zoom_level: currentZoomLevel,
        mouse_padding: currentMousePadding,
      },
    });

    let wq = `watermark=${useWatermark ? 1 : 0}&quality=${quality}`;
    if (useWatermark) {
      const wmc = wmBuildConfig();
      if (wmc.logo_position_x !== null) wq += `&wm_px=${wmc.logo_position_x.toFixed(3)}&wm_py=${wmc.logo_position_y.toFixed(3)}`;
      wq += `&wm_pos=${encodeURIComponent(wmc.logo_position)}`;
      if (wmc.footer_text) wq += `&wm_text=${encodeURIComponent(wmc.footer_text)}&wm_tc=${encodeURIComponent(wmc.footer_color)}&wm_fs=${wmc.footer_font_size}`;
      wq += `&wm_bg=${encodeURIComponent(wmc.footer_bg)}`;
    }
    _publishAnimFrames = result.previews.map(p =>
      `/api/sessions/${currentSession}/preview/${p.filename}?${wq}&_t=${Date.now()}`
    );
  } catch (e) {
    // fallback: use raw frame thumbnails
    sel.forEach(idx => {
      const f = sessionData.frames[idx];
      if (f) _publishAnimFrames.push(`/api/sessions/${currentSession}/frames/${f.filename}`);
    });
  }

  if (_publishAnimFrames.length === 0) { spinner.style.display = 'none'; return; }

  // Build dot indicators
  dots.innerHTML = _publishAnimFrames.map((_, i) =>
    `<div class="pub-anim-dot" id="pubDot${i}" style="width:8px;height:8px;border-radius:50%;background:var(--border);transition:background .2s"></div>`
  ).join('');

  // Show first frame, hide spinner
  img.src = _publishAnimFrames[0];
  img.onload = () => { spinner.style.display = 'none'; };
  _publishAnimIdx = 0;
  updatePublishAnimDot(0);
  startPublishPreview();
}

function startPublishPreview() {
  stopPublishPreview();
  const dur = parseFloat(document.getElementById('exportDuration')?.value || '0.5') * 1000;
  _publishAnimTimer = setInterval(() => {
    if (_publishAnimFrames.length === 0) return;
    _publishAnimIdx = (_publishAnimIdx + 1) % _publishAnimFrames.length;
    const img = document.getElementById('publishAnimImg');
    if (img) img.src = _publishAnimFrames[_publishAnimIdx];
    updatePublishAnimDot(_publishAnimIdx);
  }, Math.max(100, dur));
}

function stopPublishPreview() {
  if (_publishAnimTimer) { clearInterval(_publishAnimTimer); _publishAnimTimer = null; }
}

function restartPublishPreview() {
  stopPublishPreview();
  startPublishPreview();
}

function updatePublishAnimDot(activeIdx) {
  document.querySelectorAll('.pub-anim-dot').forEach((d, i) => {
    d.style.background = i === activeIdx ? 'var(--accent)' : 'var(--border)';
  });
}

// â”€â”€â”€ Watermark Configurator â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let _wmLogoDataUrl = null;  // base64 data URL of uploaded logo
let _wmPosX = null;         // custom position 0.0-1.0
let _wmPosY = null;

function wmToggle() {
  const on = document.getElementById('publishWatermark').checked;
  document.getElementById('wmFields').style.display = on ? 'block' : 'none';
  if (on) wmSetupPreviewClick();
  initPublishPreview();
}

function wmSetupPreviewClick() {
  const wrap = document.querySelector('.wm-preview-wrap') || _wmGetPreviewWrap();
  if (!wrap) return;
  if (wrap._wmClickBound) return;
  wrap._wmClickBound = true;
  wrap.addEventListener('click', (e) => {
    const img = wrap.querySelector('img');
    if (!img) return;
    const rect = img.getBoundingClientRect();
    const xPct = (e.clientX - rect.left) / rect.width;
    const yPct = (e.clientY - rect.top)  / rect.height;
    _wmPosX = Math.max(0, Math.min(1, xPct));
    _wmPosY = Math.max(0, Math.min(1, yPct));
    document.getElementById('wmPosition').value = 'custom';
    document.getElementById('wmPosDisplay').textContent =
      `(${Math.round(_wmPosX * 100)}%, ${Math.round(_wmPosY * 100)}%)`;
    _wmUpdatePin(wrap, _wmPosX, _wmPosY);
    wmChanged();
  });
}

function _wmGetPreviewWrap() {
  // The animated preview img container â€” make it a wm-preview-wrap
  const imgEl = document.getElementById('publishAnimImg');
  if (!imgEl) return null;
  const parent = imgEl.parentElement;
  if (parent && !parent.classList.contains('wm-preview-wrap')) {
    parent.classList.add('wm-preview-wrap');
  }
  return parent;
}

function _wmUpdatePin(wrap, xPct, yPct) {
  let pin = wrap.querySelector('.wm-pin');
  if (!pin) {
    pin = document.createElement('div');
    pin.className = 'wm-pin';
    pin.innerHTML = '<div class="wm-pin-dot"></div><div class="wm-pin-label">WM</div>';
    wrap.appendChild(pin);
  }
  pin.style.left = (xPct * 100) + '%';
  pin.style.top  = (yPct * 100) + '%';
  pin.style.display = 'flex';
}

function wmPositionPreset(val) {
  const presets = {
    bottom_right: [0.92, 0.92],
    bottom_left:  [0.08, 0.92],
    top_right:    [0.92, 0.08],
    top_left:     [0.08, 0.08],
    center:       [0.50, 0.50],
  };
  if (presets[val]) {
    [_wmPosX, _wmPosY] = presets[val];
    document.getElementById('wmPosDisplay').textContent =
      `(${Math.round(_wmPosX * 100)}%, ${Math.round(_wmPosY * 100)}%)`;
    const wrap = _wmGetPreviewWrap();
    if (wrap) _wmUpdatePin(wrap, _wmPosX, _wmPosY);
  }
  wmChanged();
}

function wmLogoChanged(input) {
  const file = input.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    _wmLogoDataUrl = e.target.result;
    const prev = document.getElementById('wmLogoPreview');
    prev.src = _wmLogoDataUrl;
    prev.style.display = 'inline-block';
    wmChanged();
  };
  reader.readAsDataURL(file);
}

function wmClearLogo() {
  _wmLogoDataUrl = null;
  document.getElementById('wmLogoFile').value = '';
  const prev = document.getElementById('wmLogoPreview');
  prev.src = '';
  prev.style.display = 'none';
  wmChanged();
}

function wmSetTransparent() {
  const btn = document.getElementById('wmBgTransparentBtn');
  const isTransparent = btn.classList.toggle('active');
  document.getElementById('wmBgOpacity').disabled = isTransparent;
  document.getElementById('wmBgColor').disabled   = isTransparent;
  wmChanged();
}

function wmBuildConfig() {
  const transparent = document.getElementById('wmBgTransparentBtn').classList.contains('active');
  const bgHex = document.getElementById('wmBgColor').value;
  const bgAlpha = transparent ? 0 : Math.round(parseInt(document.getElementById('wmBgOpacity').value) / 100 * 255);
  const bgHexAlpha = transparent ? '#00000000' : bgHex + bgAlpha.toString(16).padStart(2, '0');

  return {
    logo_data:      _wmLogoDataUrl || null,
    logo_position:  _wmPosX !== null ? 'custom' : document.getElementById('wmPosition').value,
    logo_position_x: _wmPosX,
    logo_position_y: _wmPosY,
    logo_size:      parseInt(document.getElementById('wmLogoSize').value),
    logo_opacity:   parseInt(document.getElementById('wmLogoOpacity').value) / 100,
    footer_text:    document.getElementById('wmText').value.trim() || null,
    footer_font_size: parseInt(document.getElementById('wmFontSize').value),
    footer_color:   document.getElementById('wmTextColor').value,
    footer_bg:      bgHexAlpha,
  };
}

function wmChanged() {
  if (document.getElementById('publishWatermark').checked) {
    initPublishPreview();
  }
}

async function wmSaveToServer() {
  const cfg = wmBuildConfig();
  try {
    await api('/branding', { method: 'POST', body: cfg });
    toast('ğŸ’¾ Zapisano branding.json');
  } catch (e) {
    toast('âŒ BÅ‚Ä…d zapisu: ' + e.message);
  }
}

// Wire up preview click on publish tab open
function _wmInitOnPublish() {
  setTimeout(() => {
    const wrap = _wmGetPreviewWrap();
    if (wrap) wmSetupPreviewClick();
  }, 300);
}

async function exportAllFormats() {
  if (!currentSession) return;
  
  const btn = document.getElementById('exportBtn');
  const originalHtml = btn.innerHTML;
  btn.innerHTML = '<span class="spinner"></span> GenerujÄ™ wszystkie formaty...';
  btn.disabled = true;
  
  const formats = ['video', 'gif', 'webm', 'zip'];
  const results = {};
  
  try {
    // Export all formats in parallel
    const exportPromises = formats.map(format => 
      api(`/sessions/${currentSession}/export`, {
        method: 'POST',
        body: {
          preset: activePreset,
          format: format,
          duration_per_frame: parseFloat(document.getElementById('exportDuration').value),
          fps: Math.round(1 / parseFloat(document.getElementById('exportDuration').value)),
          quality: parseInt(document.getElementById('exportQuality').value),
          frame_indices: [...selectedFrames].sort((a, b) => a - b),
          focus_mode: currentFocusMode,
          zoom_level: currentZoomLevel,
          mouse_padding: currentMousePadding,
          watermark: document.getElementById('publishWatermark')?.checked || false,
        },
      }).then(result => ({ format, result }))
      .catch(error => ({ format, error }))
    );
    
    const exportResults = await Promise.all(exportPromises);
    
    // Show results
    document.getElementById('exportResults').style.display = 'block';
    const linksContainer = document.getElementById('exportLinks');
    linksContainer.innerHTML = '';
    
    exportResults.forEach(({ format, result, error }) => {
      if (error) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'export-error';
        errorDiv.textContent = `âŒ ${format.toUpperCase()}: ${error.message}`;
        linksContainer.appendChild(errorDiv);
      } else {
        const previewDiv = document.createElement('div');
        previewDiv.className = 'export-preview';
        previewDiv.dataset.formatLink = format;
        
        // Create preview element based on format
        let previewElement = '';
        if (format === 'zip') {
          previewElement = `<div class="preview-icon">ğŸ“</div>`;
        } else {
          const isVideo = ['video', 'webm'].includes(format);
          const tag = isVideo ? 'video' : 'img';
          const extraAttrs = isVideo ? 'controls muted loop autoplay' : '';
          previewElement = `<${tag} src="${result.download_url}" ${extraAttrs} class="preview-media"></${tag}>`;
        }
        
        previewDiv.innerHTML = `
          <div class="preview-header">
            <span class="format-badge">${format.toUpperCase()}</span>
            <a href="${result.download_url}" download class="download-link">â¬‡ ${result.filename} (${result.size_mb} MB)</a>
          </div>
          <div class="preview-content">
            ${previewElement}
          </div>
        `;
        
        linksContainer.appendChild(previewDiv);
      }
    });
    
    toast('Wszystkie formaty wygenerowane!');
  } catch (e) {
    toast('BÅ‚Ä…d eksportu: ' + e.message);
  } finally {
    btn.innerHTML = originalHtml;
    btn.disabled = false;
  }
}

function buildSocialLinks() {
  const container = document.getElementById('socialLinks');
  const links = {
    twitter: { label: 'Twitter / X', class: 'twitter' },
    linkedin: { label: 'LinkedIn', class: 'linkedin' },
    facebook: { label: 'Facebook', class: 'facebook' },
    reddit: { label: 'Reddit', class: 'reddit' },
    telegram: { label: 'Telegram', class: 'telegram' },
  };
  for (const [key, cfg] of Object.entries(links)) {
    const btn = document.createElement('button');
    btn.className = `social-btn ${cfg.class}`;
    btn.textContent = cfg.label;
    btn.onclick = () => {
      const text = encodeURIComponent(`Check out this demo!`);
      const url = encodeURIComponent(window.location.href);
      // Will be populated from social links API
      window.open(`https://${key}.com`, '_blank');
    };
    container.appendChild(btn);
  }
}

// â”€â”€â”€ Upload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupDragDrop() {
  const zone = document.getElementById('uploadZone');
  zone.addEventListener('dragover', (e) => { e.preventDefault(); zone.classList.add('dragover'); });
  zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
  zone.addEventListener('drop', (e) => {
    e.preventDefault();
    zone.classList.remove('dragover');
    uploadFiles(e.dataTransfer.files);
  });
}

async function uploadFiles(files) {
  if (!files.length) return;
  const fd = new FormData();
  for (const f of files) fd.append('files', f);

  const res = await fetch('/api/sessions/upload', { method: 'POST', body: fd });
  const data = await res.json();

  toast(`ZaÅ‚adowano ${data.frame_count} obrazÃ³w`);
  await loadSessions();
  document.getElementById('sessionSelect').value = data.name;
  await loadSession(data.name);
}

// â”€â”€â”€ Cropped image helper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getCroppedSrc(frameIdx) {
  const p = cropPreviews[frameIdx];
  if (p && currentSession) return `/api/sessions/${currentSession}/preview/${p.filename}`;
  const frames = sessionData?.frames || [];
  if (frames[frameIdx] && currentSession) return `/api/sessions/${currentSession}/frames/${frames[frameIdx].filename}`;
  return '';
}

// â”€â”€â”€ Tab Switching â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function switchTab(name) {
  // Auto-save centers when leaving center tab
  const prevPanel = document.querySelector('.panel.active');
  if (prevPanel && prevPanel.id === 'panel-center' && name !== 'center') {
    if (currentSession && Object.keys(centerMarks).length > 0) {
      saveCenters();  // fire-and-forget, no await needed
    }
  }

  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === name));
  document.querySelectorAll('.panel').forEach(p => p.classList.toggle('active', p.id === `panel-${name}`));

  // Lazy load tab content
  if (name === 'select') {
    renderFrameGrid();
    // Auto-detect duplicates when switching to select tab
    if (sessionData && sessionData.frame_count > 1) {
      detectDuplicates();
    }
  }
  if (name === 'annotate') renderAnnotatePanel();
  if (name === 'center') renderCenterPanel();
  if (name === 'crop') {
    loadCropPreview();
    // Generate video preview when switching to crop tab
    setTimeout(() => updateVideoPreview(), 100);
  }
  if (name === 'captions') {
    if (Object.keys(cropPreviews).length === 0 && currentSession) loadCropPreview();
    loadCaptionsPanel();
  }
  if (name === 'transitions') {
    if (Object.keys(cropPreviews).length === 0 && currentSession) loadCropPreview().then(renderTransitionsPanel);
    else renderTransitionsPanel();
  }
  if (name === 'publish') {
    initPublishPreview();
    _wmInitOnPublish();
  } else {
    stopPublishPreview();
  }
}

// Update tab click handlers to use navigation
function updateTabHandlers() {
  document.querySelectorAll('.tab').forEach(tab => {
    const tabName = tab.dataset.tab;
    tab.onclick = () => navigateToTab(tabName);
  });
}

// â”€â”€â”€ Tab 5: Captions / Napisy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let captions = [];           // array of caption objects
let activeCaptionId = null;  // currently selected caption id
let capDragActive = false;   // drag state for position
let capDragCapId = null;

function capUUID() {
  return 'cap_' + Math.random().toString(36).slice(2, 9);
}

async function loadCaptionsPanel() {
  if (!currentSession) return;
  try {
    const res = await api(`/sessions/${currentSession}/captions`);
    captions = res.captions || [];
  } catch(e) {
    captions = [];
  }
  renderCaptionsList();
  if (captions.length > 0) selectCaption(captions[0].id);
}

function renderCaptionsList() {
  const list = document.getElementById('captionsList');
  const count = document.getElementById('captionCount');
  if (!list) return;
  count.textContent = `(${captions.length})`;

  if (captions.length === 0) {
    list.innerHTML = '<div style="text-align:center;padding:40px;color:var(--text2);font-size:13px">Brak napisÃ³w â€” dodaj rÄ™cznie lub wygeneruj AI</div>';
    return;
  }

  list.innerHTML = '';
  captions.forEach(cap => {
    const row = document.createElement('div');
    row.className = `caption-row${cap.id === activeCaptionId ? ' active' : ''}`;
    row.onclick = () => selectCaption(cap.id);

    const rangeLabel = cap.frame_start === cap.frame_end
      ? `#${cap.frame_start + 1}`
      : `#${cap.frame_start + 1}â€“#${cap.frame_end + 1}`;

    row.innerHTML = `
      <img class="cap-thumb" src="${getCroppedSrc(cap.frame_start)}" onerror="this.style.opacity=0.2">
      <span class="cap-text" title="${cap.text}">${cap.text || '(pusty)'}</span>
      <span class="cap-frames">${rangeLabel}</span>
      <button class="cap-del" title="UsuÅ„" onclick="event.stopPropagation(); deleteCaption('${cap.id}')">âœ•</button>
    `;
    list.appendChild(row);
  });
}

function selectCaption(id) {
  activeCaptionId = id;
  renderCaptionsList();
  renderCaptionEditor();
}

function renderCaptionEditor() {
  const editor = document.getElementById('captionEditor');
  if (!editor) return;
  const cap = captions.find(c => c.id === activeCaptionId);
  if (!cap) {
    editor.innerHTML = '<div style="text-align:center;padding:20px;color:var(--text2);font-size:13px">Kliknij napis na liÅ›cie aby edytowaÄ‡</div>';
    return;
  }

  const frames = sessionData?.frames || [];
  const thumbSrc = getCroppedSrc(cap.frame_start);
  const maxFrame = Math.max(0, frames.length - 1);

  editor.innerHTML = `
    <!-- Preview with overlay -->
    <div class="cap-preview-wrap" id="capPreviewWrap">
      <img id="capPreviewImg" src="${thumbSrc}" alt="">
      <div class="cap-overlay-text" id="capOverlayText"
           style="top:${cap.y}%;left:${cap.x}%;
                  font-size:${cap.font_size * 0.3}px;
                  color:${cap.color};
                  background:${hexToRgba(cap.bg_color, cap.bg_opacity)};
                  font-weight:${cap.bold ? 'bold' : 'normal'};
                  font-style:${cap.italic ? 'italic' : 'normal'};
                  text-align:${cap.align}">
        ${cap.text || ''}
      </div>
    </div>
    <div style="display:flex;justify-content:space-between;align-items:center;margin:0 0 2px">
      <p style="font-size:10px;color:var(--text2);margin:0">â¬† PrzeciÄ…gnij tekst aby zmieniÄ‡ pozycjÄ™</p>
      <span id="capCoordBadge" style="font-size:11px;font-family:monospace;color:var(--accent);background:var(--surface);border:1px solid var(--border);padding:2px 10px;border-radius:4px;white-space:nowrap">
        X: ${cap.x.toFixed(1)}%  Y: ${cap.y.toFixed(1)}%
      </span>
    </div>

    <!-- Text content -->
    <div class="cap-field">
      <label>Tekst napisu</label>
      <textarea id="capText" oninput="updateCaptionField('text', this.value)">${cap.text}</textarea>
    </div>

    <!-- Frame range -->
    <div class="cap-row-inline">
      <div class="cap-field">
        <label>Klatka od (#)</label>
        <input type="number" id="capFrameStart" min="1" max="${maxFrame + 1}" value="${cap.frame_start + 1}"
               oninput="updateCaptionField('frame_start', parseInt(this.value)-1); updatePreviewThumb()">
      </div>
      <div class="cap-field">
        <label>Klatka do (#)</label>
        <input type="number" id="capFrameEnd" min="1" max="${maxFrame + 1}" value="${cap.frame_end + 1}"
               oninput="updateCaptionField('frame_end', parseInt(this.value)-1)">
      </div>
    </div>

    <!-- Position with synced slider + number input -->
    <div class="cap-row-inline">
      <div class="cap-field">
        <label>Pozycja X (%)</label>
        <div style="display:flex;gap:5px;align-items:center">
          <input type="range" id="capXSlider" min="0" max="100" value="${cap.x.toFixed(1)}" step="0.5" style="flex:1"
                 oninput="setCapPos('x', parseFloat(this.value))">
          <input type="number" id="capXInput" min="0" max="100" step="0.5" value="${cap.x.toFixed(1)}"
                 style="width:58px;padding:4px 5px;background:var(--surface2);color:var(--text);border:1px solid var(--border);border-radius:6px;font-size:12px;font-family:monospace"
                 oninput="setCapPos('x', parseFloat(this.value))">
        </div>
      </div>
      <div class="cap-field">
        <label>Pozycja Y (%)</label>
        <div style="display:flex;gap:5px;align-items:center">
          <input type="range" id="capYSlider" min="0" max="100" value="${cap.y.toFixed(1)}" step="0.5" style="flex:1"
                 oninput="setCapPos('y', parseFloat(this.value))">
          <input type="number" id="capYInput" min="0" max="100" step="0.5" value="${cap.y.toFixed(1)}"
                 style="width:58px;padding:4px 5px;background:var(--surface2);color:var(--text);border:1px solid var(--border);border-radius:6px;font-size:12px;font-family:monospace"
                 oninput="setCapPos('y', parseFloat(this.value))">
        </div>
      </div>
    </div>

    <!-- Style -->
    <div class="cap-row-inline">
      <div class="cap-field">
        <label>Rozmiar czcionki</label>
        <input type="range" min="12" max="120" value="${cap.font_size}" step="2"
               oninput="updateCaptionField('font_size', parseInt(this.value)); updateOverlay(); this.nextElementSibling.textContent=this.value+'px'">
        <span style="font-size:11px;color:var(--text2)">${cap.font_size}px</span>
      </div>
      <div class="cap-field">
        <label>WyrÃ³wnanie</label>
        <select oninput="updateCaptionField('align', this.value); updateOverlay()">
          <option value="left" ${cap.align==='left'?'selected':''}>Lewo</option>
          <option value="center" ${cap.align==='center'?'selected':''}>Åšrodek</option>
          <option value="right" ${cap.align==='right'?'selected':''}>Prawo</option>
        </select>
      </div>
    </div>

    <!-- Colors -->
    <div class="cap-row-inline">
      <div class="cap-field">
        <label>Kolor tekstu</label>
        <input type="color" value="${cap.color}"
               oninput="updateCaptionField('color', this.value); updateOverlay()"
               style="width:100%;height:36px;border-radius:6px;border:1px solid var(--border);cursor:pointer">
      </div>
      <div class="cap-field">
        <label>Kolor tÅ‚a</label>
        <input type="color" value="${cap.bg_color}"
               oninput="updateCaptionField('bg_color', this.value); updateOverlay()"
               style="width:100%;height:36px;border-radius:6px;border:1px solid var(--border);cursor:pointer">
      </div>
      <div class="cap-field">
        <label>Krycie tÅ‚a</label>
        <input type="range" min="0" max="1" step="0.05" value="${cap.bg_opacity}"
               oninput="updateCaptionField('bg_opacity', parseFloat(this.value)); updateOverlay(); this.nextElementSibling.textContent=Math.round(this.value*100)+'%'">
        <span style="font-size:11px;color:var(--text2)">${Math.round(cap.bg_opacity*100)}%</span>
      </div>
    </div>

    <!-- Bold/Italic -->
    <div class="cap-row-inline">
      <div class="cap-field">
        <label>Pogrubienie</label>
        <button class="btn ${cap.bold ? 'btn-primary' : 'btn-outline'}" id="capBoldBtn"
                onclick="updateCaptionField('bold', !${cap.bold}); renderCaptionEditor()">
          <b>B</b>
        </button>
      </div>
      <div class="cap-field">
        <label>Kursywa</label>
        <button class="btn ${cap.italic ? 'btn-primary' : 'btn-outline'}" id="capItalicBtn"
                onclick="updateCaptionField('italic', !${cap.italic}); renderCaptionEditor()">
          <i>I</i>
        </button>
      </div>
    </div>

    <!-- Copy to frames (Canva-style spanning) -->
    <div class="cap-field" style="border-top:1px solid var(--border);padding-top:10px;margin-top:4px">
      <label style="font-weight:600">Kopiuj / rozciÄ…gnij na klatki</label>
      <div class="cap-copy-row">
        <input type="number" id="capCopyCount" min="1" max="50" value="1" title="Liczba kolejnych klatek">
        <span style="font-size:12px;color:var(--text2)">klatek</span>
        <button class="btn btn-outline" style="padding:5px 12px;font-size:12px" onclick="copyCaptionToFrames()" title="UtwÃ³rz kopie napisu na kolejnych N klatkach">
          ğŸ“‹ Kopiuj styl
        </button>
        <button class="btn btn-outline" style="padding:5px 12px;font-size:12px" onclick="extendCaptionSpan()" title="RozciÄ…gnij zakres klatka_do na N klatek">
          â†” RozciÄ…gnij
        </button>
      </div>
      <p style="font-size:10px;color:var(--text2);margin:4px 0 0">Kopiuj styl = nowe napisy na kolejnych klatkach â€¢ RozciÄ…gnij = jeden napis na wielu klatkach</p>
    </div>
  `;

  // Enable drag on overlay text
  setupCaptionDrag();
}

function hexToRgba(hex, opacity) {
  const r = parseInt(hex.slice(1,3), 16);
  const g = parseInt(hex.slice(3,5), 16);
  const b = parseInt(hex.slice(5,7), 16);
  return `rgba(${r},${g},${b},${opacity})`;
}

function updateCaptionField(field, value) {
  const cap = captions.find(c => c.id === activeCaptionId);
  if (!cap) return;
  cap[field] = value;
}

function updateOverlay() {
  const cap = captions.find(c => c.id === activeCaptionId);
  const overlay = document.getElementById('capOverlayText');
  if (!cap || !overlay) return;
  overlay.style.top = cap.y + '%';
  overlay.style.left = cap.x + '%';
  overlay.style.fontSize = (cap.font_size * 0.3) + 'px';
  overlay.style.color = cap.color;
  overlay.style.background = hexToRgba(cap.bg_color, cap.bg_opacity);
  overlay.style.fontWeight = cap.bold ? 'bold' : 'normal';
  overlay.style.fontStyle = cap.italic ? 'italic' : 'normal';
  overlay.style.textAlign = cap.align;
  overlay.textContent = cap.text;
  // Sync coordinate badge
  const badge = document.getElementById('capCoordBadge');
  if (badge) badge.textContent = `X: ${cap.x.toFixed(1)}%  Y: ${cap.y.toFixed(1)}%`;
  // Sync sliders and number inputs (skip the currently-active element to avoid cursor jump)
  const active = document.activeElement;
  const xs = document.getElementById('capXSlider');
  const xi = document.getElementById('capXInput');
  const ys = document.getElementById('capYSlider');
  const yi = document.getElementById('capYInput');
  if (xs && xs !== active) xs.value = cap.x.toFixed(1);
  if (xi && xi !== active) xi.value = cap.x.toFixed(1);
  if (ys && ys !== active) ys.value = cap.y.toFixed(1);
  if (yi && yi !== active) yi.value = cap.y.toFixed(1);
}

function setCapPos(axis, value) {
  const val = Math.max(0, Math.min(100, isNaN(value) ? 0 : parseFloat(value)));
  const cap = captions.find(c => c.id === activeCaptionId);
  if (!cap) return;
  cap[axis] = val;
  updateOverlay();
}

function updatePreviewThumb() {
  const cap = captions.find(c => c.id === activeCaptionId);
  const img = document.getElementById('capPreviewImg');
  if (!cap || !img || !sessionData) return;
  const src = getCroppedSrc(cap.frame_start);
  if (src) img.src = src;
}

function setupCaptionDrag() {
  const overlay = document.getElementById('capOverlayText');
  const wrap = document.getElementById('capPreviewWrap');
  if (!overlay || !wrap) return;

  overlay.style.cursor = 'move';
  overlay.style.userSelect = 'none';

  let dragging = false, startX, startY, startPctX, startPctY;

  overlay.addEventListener('mousedown', e => {
    e.preventDefault();
    dragging = true;
    startX = e.clientX;
    startY = e.clientY;
    const cap = captions.find(c => c.id === activeCaptionId);
    startPctX = cap.x;
    startPctY = cap.y;
  });

  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    const rect = wrap.getBoundingClientRect();
    const dx = ((e.clientX - startX) / rect.width) * 100;
    const dy = ((e.clientY - startY) / rect.height) * 100;
    const cap = captions.find(c => c.id === activeCaptionId);
    if (!cap) return;
    cap.x = Math.max(0, Math.min(100, startPctX + dx));
    cap.y = Math.max(0, Math.min(100, startPctY + dy));
    updateOverlay();
  });

  window.addEventListener('mouseup', () => { dragging = false; });
}

function addCaption() {
  const frames = sessionData?.frames || [];
  const firstSelected = [...selectedFrames].sort((a, b) => a - b)[0] ?? 0;
  const newCap = {
    id: capUUID(),
    frame_start: firstSelected,
    frame_end: firstSelected,
    text: 'Nowy napis',
    x: 50.0, y: 85.0,
    font_size: 32,
    color: '#ffffff',
    bg_color: '#000000',
    bg_opacity: 0.5,
    bold: false,
    italic: false,
    align: 'center',
  };
  captions.push(newCap);
  renderCaptionsList();
  selectCaption(newCap.id);
}

function deleteCaption(id) {
  captions = captions.filter(c => c.id !== id);
  if (activeCaptionId === id) {
    activeCaptionId = captions.length > 0 ? captions[0].id : null;
  }
  renderCaptionsList();
  if (activeCaptionId) renderCaptionEditor();
  else document.getElementById('captionEditor').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text2)">Brak napisÃ³w</div>';
}

function autoCaptionsFromFrames() {
  const selected = [...selectedFrames].sort((a, b) => a - b);
  if (selected.length === 0) { toast('Zaznacz klatki w zakÅ‚adce WybÃ³r klatek'); return; }
  captions = selected.map(idx => ({
    id: capUUID(),
    frame_start: idx,
    frame_end: idx,
    text: `Klatka #${idx + 1}`,
    x: 50.0, y: 85.0,
    font_size: 32,
    color: '#ffffff',
    bg_color: '#000000',
    bg_opacity: 0.5,
    bold: false,
    italic: false,
    align: 'center',
  }));
  renderCaptionsList();
  if (captions.length > 0) selectCaption(captions[0].id);
  toast(`Utworzono ${captions.length} napisÃ³w`);
}

async function saveCaptions() {
  if (!currentSession) return;
  try {
    await api(`/sessions/${currentSession}/captions`, {
      method: 'POST',
      body: { captions },
    });
    toast(`Zapisano ${captions.length} napisÃ³w`);
  } catch(e) {
    toast('BÅ‚Ä…d zapisu: ' + e.message);
  }
}

function clearAllCaptions() {
  if (!confirm('UsunÄ…Ä‡ wszystkie napisy?')) return;
  captions = [];
  activeCaptionId = null;
  renderCaptionsList();
  document.getElementById('captionEditor').innerHTML = '<div style="text-align:center;padding:20px;color:var(--text2)">Brak napisÃ³w</div>';
}

function copyCaptionToFrames() {
  const cap = captions.find(c => c.id === activeCaptionId);
  if (!cap) return;
  const n = parseInt(document.getElementById('capCopyCount')?.value) || 1;
  const selected = [...selectedFrames].sort((a, b) => a - b);
  const curPos = selected.indexOf(cap.frame_start);
  const targets = selected.slice(curPos + 1, curPos + 1 + n);
  let added = 0;
  targets.forEach(idx => {
    if (!captions.find(c => c.frame_start === idx && c.frame_end === idx)) {
      captions.push({ ...cap, id: capUUID(), frame_start: idx, frame_end: idx });
      added++;
    }
  });
  renderCaptionsList();
  toast(`Skopiowano styl na ${added} klatek`);
}

function extendCaptionSpan() {
  const cap = captions.find(c => c.id === activeCaptionId);
  if (!cap) return;
  const n = parseInt(document.getElementById('capCopyCount')?.value) || 1;
  const selected = [...selectedFrames].sort((a, b) => a - b);
  const curPos = selected.indexOf(cap.frame_start);
  const endPos = Math.min(curPos + n - 1, selected.length - 1);
  cap.frame_end = selected[endPos] ?? cap.frame_start;
  renderCaptionsList();
  renderCaptionEditor();
  toast(`Napis rozciÄ…gniÄ™ty na klatki #${cap.frame_start + 1}â€“#${cap.frame_end + 1}`);
}

// â”€â”€â”€ Tab 6: Transitions / PrzejÅ›cia â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TRANSITION_TYPES = [
  { value: 'none',        label: 'Brak' },
  { value: 'fade',        label: 'ğŸŒ… Fade (zanikanie)' },
  { value: 'pixelize',    label: 'ğŸŸ¦ Pixelize (pikselizacja)' },
  { value: 'blur',        label: 'ğŸ’¨ Blur (rozmycie)' },
  { value: 'slide_left',  label: 'â—€ Slide lewo' },
  { value: 'slide_right', label: 'â–¶ Slide prawo' },
];

function renderTransitionsPanel() {
  const grid = document.getElementById('transitionsGrid');
  if (!grid || !sessionData) return;
  grid.innerHTML = '';
  const selected = [...selectedFrames].sort((a, b) => a - b);
  if (selected.length < 2) {
    grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;color:var(--text2);font-size:13px">Zaznacz co najmniej 2 klatki aby ustawiÄ‡ przejÅ›cia</div>';
    return;
  }
  selected.forEach((idx, i) => {
    if (i === 0) return;
    const tr = transitions[idx] || { type: 'none', duration: 0.3 };
    const src = getCroppedSrc(idx);
    const prevSrc = getCroppedSrc(selected[i - 1]);
    const card = document.createElement('div');
    card.className = 'transition-card';
    card.innerHTML = `
      <div style="display:flex;gap:4px;align-items:center;justify-content:center">
        <img src="${prevSrc}" style="width:44%;aspect-ratio:16/9;object-fit:cover;border-radius:4px;opacity:0.7" onerror="this.style.opacity=0.1">
        <span style="font-size:16px;color:var(--text2)">â†’</span>
        <img src="${src}" style="width:44%;aspect-ratio:16/9;object-fit:cover;border-radius:4px" onerror="this.style.opacity=0.1">
      </div>
      <div class="tc-label">PrzejÅ›cie â†’ klatka #${idx + 1}</div>
      <select onchange="setTransition(${idx}, 'type', this.value)">
        ${TRANSITION_TYPES.map(t => `<option value="${t.value}"${tr.type === t.value ? ' selected' : ''}>${t.label}</option>`).join('')}
      </select>
      <div style="display:flex;align-items:center;gap:6px">
        <span style="font-size:11px;color:var(--text2);white-space:nowrap">Czas:</span>
        <input type="range" min="0.1" max="1.0" step="0.1" value="${tr.duration}"
               oninput="setTransition(${idx},'duration',parseFloat(this.value));this.nextElementSibling.textContent=parseFloat(this.value).toFixed(1)+'s'"
               style="flex:1">
        <span style="font-size:11px;color:var(--text2);white-space:nowrap">${parseFloat(tr.duration).toFixed(1)}s</span>
      </div>
    `;
    grid.appendChild(card);
  });
}

function setTransition(idx, field, value) {
  if (!transitions[idx]) transitions[idx] = { type: 'none', duration: 0.3 };
  transitions[idx][field] = value;
}

function applyTransitionToAll() {
  const type = document.getElementById('globalTransitionType')?.value || 'none';
  const duration = parseFloat(document.getElementById('globalTransitionDuration')?.value || 0.3);
  const selected = [...selectedFrames].sort((a, b) => a - b);
  selected.forEach((idx, i) => {
    if (i === 0) return;
    transitions[idx] = { type, duration };
  });
  renderTransitionsPanel();
  toast(`PrzejÅ›cie "${TRANSITION_TYPES.find(t=>t.value===type)?.label||type}" zastosowane`);
}

function clearAllTransitions() {
  transitions = {};
  renderTransitionsPanel();
  toast('PrzejÅ›cia wyczyszczone');
}

function updateLlmModelPlaceholder() {
  const provider = document.getElementById('llmProvider').value;
  const modelInput = document.getElementById('llmModel');
  const defaults = {
    openai: 'gpt-4o-mini',
    anthropic: 'claude-3-haiku-20240307',
    ollama: 'llava',
    gemini: 'gemini-1.5-flash',
  };
  modelInput.value = defaults[provider] || 'gpt-4o-mini';
  modelInput.placeholder = defaults[provider] || '';
}

async function generateCaptionsLLM() {
  if (!currentSession) return;
  const apiKey = document.getElementById('llmApiKey').value.trim();
  const provider = document.getElementById('llmProvider').value;
  const model = document.getElementById('llmModel').value.trim();
  const language = document.getElementById('llmLanguage').value;
  const style = document.getElementById('llmStyle').value;

  // Pass API key as env hint for liteLLM
  if (apiKey) {
    const envVarMap = { openai: 'OPENAI_API_KEY', anthropic: 'ANTHROPIC_API_KEY', gemini: 'GEMINI_API_KEY', ollama: '' };
    const envVar = envVarMap[provider];
    if (envVar) {
      toast(`Uwaga: klucz API przesyÅ‚any przez UI â€” ustaw zmiennÄ… ${envVar} w Å›rodowisku dla bezpieczeÅ„stwa`);
    }
  }

  const btn = document.getElementById('llmGenerateBtn');
  const status = document.getElementById('llmStatus');
  btn.disabled = true;
  btn.textContent = 'â³ GenerujÄ™...';
  status.textContent = 'WysyÅ‚am obrazy do modelu...';

  try {
    const frameIndices = [...selectedFrames].sort((a, b) => a - b);
    const result = await fetch(`/api/sessions/${currentSession}/captions/generate`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(apiKey ? { 'X-LLM-API-Key': apiKey } : {}),
      },
      body: JSON.stringify({
        frame_indices: frameIndices.length > 0 ? frameIndices : null,
        provider,
        model,
        language,
        style,
      }),
    });

    if (!result.ok) {
      const err = await result.json().catch(() => ({ detail: result.statusText }));
      throw new Error(err.detail || result.statusText);
    }

    const data = await result.json();
    captions = data.captions;
    renderCaptionsList();
    if (captions.length > 0) selectCaption(captions[0].id);
    status.textContent = `âœ… Wygenerowano ${captions.length} napisÃ³w (${data.model})`;
    toast(`âœ… ${captions.length} napisÃ³w przez AI`);
  } catch(e) {
    status.textContent = `âŒ ${e.message}`;
    toast('BÅ‚Ä…d LLM: ' + e.message);
  } finally {
    btn.disabled = false;
    btn.textContent = 'ğŸ¤– Generuj napisy AI';
  }
}

// â”€â”€â”€ Crop Tab Tools â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function resetCropDefaults() {
  currentFocusMode = 'screen';
  currentZoomLevel = 1.0;
  currentMousePadding = 20;
  document.querySelectorAll('input[name="focusMode"]').forEach(r => { r.checked = r.value === 'screen'; });
  const zs = document.getElementById('zoomSlider'); if (zs) zs.value = 1;
  const zv = document.getElementById('zoomValue'); if (zv) zv.textContent = '1.0x';
  const ps = document.getElementById('paddingSlider'); if (ps) ps.value = 20;
  const pv = document.getElementById('paddingValue'); if (pv) pv.textContent = '20%';
  document.getElementById('zoomControls').style.display = 'none';
  syncConfigToURL();
  loadCropPreview();
  toast('Ustawienia przywrÃ³cone do domyÅ›lnych');
}

function previewAllPresets() {
  toast('PodglÄ…d wszystkich presetÃ³w â€” w przygotowaniu');
}
function fitToContent() {
  toast('Dopasowanie do treÅ›ci â€” w przygotowaniu (wymaga analizy obrazu)');
}
function addCustomPreset() {
  const input = prompt('Podaj rozmiar (np. 800x600):', '800x600');
  if (!input) return;
  const [w, h] = input.split('x').map(Number);
  if (!w || !h) { toast('NieprawidÅ‚owy format â€” uÅ¼yj WxH'); return; }
  const key = `custom_${w}x${h}`;
  presets[key] = { label: `Custom ${w}Ã—${h}`, w, h };
  activePreset = key;
  renderPresetBars();
  loadCropPreview();
  toast(`Dodano wÅ‚asny preset ${w}Ã—${h}`);
}
function advancedSmartCrop() { toast('AI Smart Crop â€” wymaga opencv-python: pip install opencv-python'); }
function advancedUpscale() { toast('AI Upscale â€” wymaga realesrgan: pip install realesrgan'); }
function advancedSimilarity() { toast('AI detekcja â€” wymaga scikit-image: pip install scikit-image'); }
function advancedAutoCenter() { toast('AI auto-center â€” wymaga YOLO/SAM: w przygotowaniu'); }
function advancedVideoExport() { toast('Zaawansowany eksport FFmpeg â€” w przygotowaniu'); }

// â”€â”€â”€ Publish Tab Tools â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openExportsFolder() {
  if (!currentSession) { toast('Brak aktywnej sesji'); return; }
  window.open(`/api/exports/`, '_blank');
  toast('Folder eksportÃ³w otwarty');
}

function copyShareURL() {
  const url = window.location.href;
  navigator.clipboard.writeText(url).then(() => {
    toast('Link skopiowany do schowka');
  }).catch(() => {
    prompt('Skopiuj link:', url);
  });
}

function addWatermark() {
  const chk = document.getElementById('publishWatermark');
  if (chk) { chk.checked = true; wmToggle(); }
  const fields = document.getElementById('wmFields');
  if (fields) fields.style.display = 'block';
  toast('Konfigurator znaku wodnego otwarty');
}

// â”€â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function toast(msg) {
  const t = document.getElementById('toast');
  t.textContent = msg;
  t.classList.add('show');
  setTimeout(() => t.classList.remove('show'), 2500);
}
</script>
</body>
</html>
